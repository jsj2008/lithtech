[BaseClass]
ClassDescription = "DO NOT CREATE OBJECTS OF THIS TYPE.  BAD THINGS **WILL** HAPPEN!!!!"
Name = "Name of the object.  The name is NOT case sensitive.  Multiple objects can share the same name (however, this WILL cause problems in NOLF)."
Pos = "Position of the object in world coordinates."
Rotation = "Rotation of the object in the world (i.e., Pitch, Yaw, Roll of the object)."
DamageProperties = "This is a subset of properties that define how the object deals with damage."
HitPoints = "This is the number of hitpoints the object has when it is first created in the world."
MaxHitPoints = "This is the maximum number of hitpoints that the object can ever have."
Armor = "This is the amount of armor that the object has when it is created."
MaxArmor = "This is the maximum amount of armor that the object can ever have."
DamagePercentForCommand = "This specifies the percentage of MaxHitPoints that HitPoints should be at to send the DamagePercentCommand."
DamagePercentCommand = "When HitPoints is below DamagePercentForCommand * MaxHitPoints this command will be processed."
DamageTriggerCounter = "This specifies how many times the object must be damaged before the damage message will be sent."
DamageCommand = "This is the command string that is sent when the object receives damage from any source."
DamageTriggerNumSends = "This specifies how many times the damage message will be sent."
DamagerMessage = "This is the command string that is sent to the object that caused the damage."
DeathCommand = "This is the command string that is sent when the object has been destroyed."
PlayerDeathCommand = "This is the command string that is sent when the player destroys the object."
PlayerDamageCommand = "This is the command string that is sent when the player damages the object."
KillerMessage = "This command string is sent to the object that destroys this object."
CanHeal = "Toggles whether the object can be healed."
CanRepair = "Toggles whether the object can be repaired."
CanDamage = "Toggles whether the object can be damaged."
Mass = "This value sets the mass of the object within the game."
NeverDestroy = "Toggles whether the object can be destroyed."
Energy = "Not used in the creation of NOLF2 and is unsupported."
MaxEnergy = "Not used in the creation of NOLF2 and is unsupported."
Visible = "This flag toggles the visibility of the object."
RenderGroup = "The object render group that this object will be placed in. These groups can be turned on or off in order to control high level visibility of objects. Valid values are 0-255 with 0 commonly meaning no group."
ExplosionProperties = "Not used in the creation of NOLF2 and is unsupported."
SearchProperties = "This is a subset of properties that define how the object behaves when searched."
SpecificItems = "This property allows you to enter one specific item that is in the level that the player will always find if they search this object.  The object listed here will recieve an ACTIVATE message sent by the player that searched the object so the item can be picked up.  Examples of objects that can be listed here are: Intelligence, KeyItems, WeaponItems... etc."
RandomItemSet = "A dropdown list of SearchSets that will define what the player can recieve while searching the object.  SearchSets are defined in searchitems.txt."
SearchSoundName = "A .wav file that will be played while the object is being searched."
SearchSoundRadius = "This value sets the falloff radius for the sound that will be played while being searched."

[Brush]
Pos = "Position of the center of the brush in world coordinates."
Rotation = "Rotation of the brush in the world (i.e., Pitch, Yaw, Roll of the object)."
NotAStep = "Setting this flag to true will tell the physics of the character to not try to stair step onto this brush. It is particularly useful for railings on stairs."
Type = "Controls the behavior of the brush. This allows brushes to serve as multiple functions and specifies what properties they will have."
Lighting = "Determines the type of lighting that will be applied to the brush. Brushes can be gouraud or lightmapped."
Detail = "Determines if it is a detail brush. There should only be one detail brush in the level and should be a convex space containing the level."
LightControl = "The lighting properties of the brush."
TextureEffect = "The name of the effect that will be applied to the brushes textures. This allows for dynamic movement of textures."
AmbientLight = "The amount of light that will be added to this brush during the lighting phase."
LMGridSize = "Specifies how many texels are covered by a single lightmap pixel. Smaller numbers create finer lightmaps. 0 specifies using the default."
ClipLight = "Specifies whether or not this brush will cast shadows onto other brushes. False means that light will pass through it."
CastShadowMesh = "Determines if this brush will block light when shadow meshing."
ReceiveLight = "Specifies whether or not lights will effect this brush. If false, it will receive no lighting from lights and will just use the ambient."
ReceiveShadows = "Determines if this brush will have shadows cast on it. If false it will just do direct lighting."
ReceiveSunlight = "Determines if this brush will receive sunlight from the environment."
LightPenScale = "Determines the offset that will be applied to the sample when lighting. This should be 0 except for brushes that exhibit self shadowing in which case it should be increased."
CreaseAngle = "When doing lighting, this will determine creases beyond the specified angle and will break the brush so that lighting is not smooth across the boundary."
RenderGroup = "The object render group that this object will be placed in. These groups can be turned on or off in order to control high level visibility of objects. Valid values are 0-255 with 0 commonly meaning no group."

[Decal]
Pos = "Position of the decal projector."
Rotation = "Orientation of the decal projector indicating the direciton the decal will be projected."
ProjectDims = "The dimensions of the decal that will be projected. This corresponds to the Width Height and Depth."
NearClip = "Allows the offsetting of the near clipping plane so it can be moved forward and backward to allow more of the world to be covered."
Occlude = "If this is set to true, the decal will occlude itself, meaning that it will not go through brushes."
HitWorldModels = "If set to true, it will create decals for any world models it hits, otherwise it ignores them entirely."
Texture = "The name of the texture or sprite that the decal will project onto the world."
IgnoreBrushes = "A comma separated list of the names of any brushes that should be ignored in the decal generation process."
TextureEffect = "The name of the texture effect that should be applied to the decal."
UOffset = "An offset for the texture in the X direction, this can range from 0 to 1, so for example if it was 0.5 the resulting texture would be offset halfway in the X direction."
VOffset = "An offset for the texture in the Y direction, this can range from 0 to 1, so for example if it was 0.5 the resulting texture would be offset halfway in the Y direction."

[AmmoBox]
Filename = "The model file used to represent the AmmoBox in the game."
Skin = "The  texture file used on the model."
AmmoType1 = "A pull down menu used to choose a type of ammunition to be contained within the powerup."
AmmoCount1 = "The quantity of ammunition."

[Camera]
ActiveTime = "If you want a camera to return to the player after a set period, give the camera a time-limit property."
AllowPlayerMovement = "Choose whether the player can move or not while the camera's running. Obviously, in most cases the camera should keep players still."
OneTime = "Keeps the camera from being activated after it's been run once, even if it's triggered again."
Type = "There are two types of camera: full-screen = 0 and cinematic letterboxed = 1."
StartActive = "Allows you to have the camera start when the level starts for an intro cutscene."
IsListener = "If you want the camera to relay sounds it hears to the player instead of the sounds at the player's location, use this flag."
CleanupCommand = "A command that will be executed when the Camera is turned off, either by a message or by the player skipping it."
CanSkip = "If set to true, the player can interrupt the cinematic by pressing the action key in the game. If this flag is set to false, the cinematic cannot be interrupted."
OnSkipCleanupOnly = "If set to true, only the CleanupCommand will be sent if the player skips the cinematic.  The camera will be able to be activated again even if OneTime is set to true."
FovX = "The starting Field Of View X value.  Note: You can dynamicly change the FovX & FovY values of a camera by sending it an FOV message."
FovY = "The starting Field Of View Y value.  Note: You can dynamicly change the FovX & FovY values of a camera by sending it an FOV message."

[ClientLightFX]
OnlyLightWorldFlag = "If you don't want this light to illuminate models, set this flag to true. This will tell it to light only world geometry."
RadiusWaveform = "The waveform that determines how the light cyles between RadiusMin, and RadiusMax. Here are some of the valid values used in NOLF. 0=No waveform, light will not cycle. 1=Square waveform--Light will cycle instantly between Min to Max values. 2=Saw waveform--Light will cycle from Min to Max along linear values. 3=Ramp Up--Light will ramp up from Min to Max values and then reset directly to Min. 4=Ramp Down--Light will ramp down from Max to Min values and then reset to Max. 5=Sine--Light value follows a Sine wave path between Min and Max. 6=Flicker 1--Light follows a flicker pattern that only has Min and Max values. 7=Flicker 2--Light follows a more 'organic' flicker pattern. 8=Flicker 3--Mostly on flicker -- good for flaky fluourescents. 9=Flicker 4--Mostly off flicker -- good for really flaky fluourescents. 10=Strobe--Light pulses from Max to Min. 11=Search--Light follows a Sine pattern with some wait time in the Min state."
IntensityWaveform = "The wave form that determines how the light cyles between IntensityMin, and IntensityMax. Here are some of the valid values used in NOLF. 0=No waveform, light will not cycle. 1=Square waveform--Light will cycle instantly between Min to Max values. 2=Saw waveform--Light will cycle from Min to Max along linear values. 3=Ramp Up--Light will ramp up from Min to Max values and then reset directly to Min. 4=Ramp Down--Light will ramp down from Max to Min values and then reset to Max. 5=Sine--Light value follows a Sine wave path between Min and Max. 6=Flicker 1--Light follows a flicker pattern that only has Min and Max values. 7=Flicker 2--Light follows a more 'organic' flicker pattern. 8=Flicker 3--Mostly on flicker -- good for flaky fluourescents. 9=Flicker 4--Mostly off flicker -- good for really flaky fluourescents. 10=Strobe--Light pulses from Max to Min. 11=Search--Light follows a Sine pattern with some wait time in the Min state."
HitPoints = "This property was not used in the creation of NOLF and is not supported."
LightSwitch = "If set to true, the light begins in the on position. If set to false, the light begins in the off position."
LifeTime = "For lights that you only want to operate for a specified period, you can specify a time after which the light shuts off."
Color = "The color that the light will emit. You select the color from Windows' color picker dialog."
IntensityMin = "This value set the lowest light intensity level that the light will cycle to. It uses the same type of values as BrightScale for regular lights, where .25 would be very dim and 1.5 would be intensely bright. Note that intensity values are not tied to their corresponding radius values, so you could easily make a light that starts off dim and large, and then contracts to become bright but tiny. Likewise, you could set the intensity and radius of the light to be out of phase with one another."
IntensityMax = "This value set the highest light intensity level that the light will cycle to. Uses the same type of values as BrightScale for regular lights, where .25 would be very dim and 1.5 would be intensely bright."
IntensityFreq = "This value specifies the frequency that the IntensityWaveform follows. The higher the value, the faster the light will cycle. Fractional values are accepted."
IntensityPhase = "This value specifies the phase offset that the IntensityWaveform follows. Values are in degrees between 0 and 360. A value of 180 will cycle exactly out of phase with a ClientLightFX with the same frequency and an offset of 0. ClientLightFX objects with the same IntensityFreq and IntensityPhase will play in sync."
DirLight = "Setting this flag to true will change the ClientLightFX from a point light to a directional light."
DirLightRadius = "This value sets the falloff radius of the directional light in Dedit units."
FOV = "This value sets the field of view of the directional light in degrees."
RadiusMin = "This value sets the smallest falloff radius that the light will cycle to."
RadiusMax = "This value sets the largest falloff radius that the light will cycle to."
RadiusFreq = "Length of time for the light to complete one cycle from RadiusMin to RadiusMax."
RadiusPhase = "Determines where in the light's cycle from RadiusMin to RadiusMax the light begins, measured in degrees from 0 to 360. If you wanted to do police lights that strobe out of sync from one another, you'd set this value to 0 for the first and 180 for the second. When the first light was just starting up, the second would be halfway done and vice versa."
RampUpSound = "You could specify a sound for the light that is played as the light turns on for things like a switched light source or a lighting flash."
RampDownSound = "See RampUpSound."
CastShadowsFlag = "This flag toggles whether or not the light will cast shadows."
SolidLightFlag = "This flag tells the light to use the 'flashlight' method for light."
DontLightBackfacingFlag = "If DontLightBackfacingFlag is set to true, the light will not light backfacing polies. Useful to keep lights from shining through walls, for instance."
UseLightAnims = "If set to true, the ClientLightFX object will create lightmaps when the level is processed. If set to false, no lightmaps will be created and the lighting will be accomplished using dynamic lights at runtime."
UseShadowMaps = "If the UseLightMaps flag has been set to true, this flag will determine what kind of light maps are generated when the level is processed. If set to false, high quality lightmaps the same as those used to lightmap the rest of the world geometry will be created. If set to true, the lightmaps created will be a rougher looking version that takes up about a tenth the size of memory."

[Controller]
Target0 = "The name of an object you wish to control."
Target1 = "The name of an object you wish to control."
Target2 = "The name of an object you wish to control."
Target3 = "The name of an object you wish to control."
Target4 = "The name of an object you wish to control."
Target5 = "The name of an object you wish to control."
Target6 = "The name of an object you wish to control."
Target7 = "The name of an object you wish to control."

[DemoSkyWorldModel]
SkyDims = "Takes the X, Y and Z dimensions of the DemoSkyWorldModel. These need to be large enough to encompass all geometry that you plan to show in your skybox. Only one object per level should have its Dims set."
Flags = "This property was not used in the creation of NOLF and is not supported."
Index = "The object's index determines the order in which it's drawn. Objects with low Index values are rendered first (and thus at the back), while objects with a higher index are rendered last and at the front."
InnerPercentX = "Determines the amount of player motion that's passed on to the camera rendering the sky. If the value is set to 0.100, only ten percent of the player's movement will be passed on to the camera. Camera movement is used to simulate parallax movement of objects in the sky. Be sure that if you give the cameras a lot of motion, you'll need to make your skybox large enough that the camera doesn't move outside it."
InnerPercentY = "Determines the amount of player motion that's passed on to the camera rendering the sky. If the value is set to 0.100, only ten percent of the player's movement will be passed on to the camera. Camera movement is used to simulate parallax movement of objects in the sky. Be sure that if you give the cameras a lot of motion, you'll need to make your skybox large enough that the camera doesn't move outside it."
InnerPercentZ = "Determines the amount of player motion that's passed on to the camera rendering the sky. If the value is set to 0.100, only ten percent of the player's movement will be passed on to the camera. Camera movement is used to simulate parallax movement of objects in the sky. Be sure that if you give the cameras a lot of motion, you'll need to make your skybox large enough that the camera doesn't move outside it."

[DirLight]
ClipLight = "Determines whether the light stops when it hits walls. Sometimes, although rarely, it's useful to have a light pass through walls after it hits them."
LightObjects = "You can use this flag to decide whether or not this light affects model objects at all. Sometimes it's beneficial to have specific lights illuminate models that aren't the same color or setting as the rest of world lighting."
LightRadius = "Determines the total range of the light's effects. Anything outside this range isn't lit at all by this light."
FastLightObjects = "When TRUE, this light will only cast a very simplified light on models. If it's FALSE, the light will emit highly accurate light on the model."
InnerColor = "Determines the color of the light at the exact center of the Light object. Light falls off gradually from this center point."
OuterColor = "Determines the color of the light at the exact edge of its LightRadius. This is the color that the light fades to from its InnerColor. Can be useful if you want to stack lights together to get a special effect."
FOV = "Field Of View. Sets the angle within which the light actually emits. If FOV is 90 degrees, the light will fill a 90-degree arc around its center of aim."
BrightScale = "A multiplier that acts like a dimmer switch. If set to 1, the light will be normal brightness. If you set to 1.5, it will be half again as bright. At 0.5, the light will be half-bright."
CastShadows = "Determines if this light will cast shadows. If false it will go through all brushes to light them."
LightAttenuation = "Controls parameters of how the light falls of at a distance. This is only valid for D3D lighting model and is commonly not changed."
ConvertToAmbient = "Specifies an amount of light from 0-1 that when lighting models will be taken out of the direct lighting and instead will ambiently light an object. This helps fill out lighting on all sides of a character."
ObjectBrightScale = "Specifies a scalar to allow increasing brightness on models. For example, if it is 1.1, it will be 10% brighter on models than the world."
Attenuation = "Specifies the attenuation method that will be used in the lighting. This controls the equation used to determine intensity as distance from the light increases."
CastShadowMesh = "Determines if this light will be used to cut up geometry when doing shadow meshing."
Size = "When doing shadow meshing this determines the diameter of the light when calculating the lighting umbra and penumbra."

[DisplayMeter]
Phase1 = "This is a value that corresponds with a section of the bar meter that is displayed on the screen. When the value is achieved, the section of the bar is removed."
RemoveWhenEmpty = "This flag sets whether or not the bar meter should be removed from the screen when empty."

[DisplayTimer]
StartCommand = "This is the command string that is sent when the timer begins its count down."
EndCommand = "This is the command string that is sent when the timer finishes counting down to 0."
RemoveWhenDone = "By default the timer is removed when the time runs out.  If you want to reuse a timer set the RemoveWhenDone property to FALSE."
Team = "This is a dropdown that allows you to set which team the timer is targetting."

[EventCounter]
Event1IncToValCmd = "This is the command string that will be sent if the EventValue for this Event has been reached through incremental ascension."
Event1DecToValCmd = "This is the command string that will be sent if the EventValue for this Event has been reached through incremental descent."
Event1Value = "This is the numeric value at which either the EventIncToValCmd or EventDecToValCmd will be sent."
StartingValue = "This is the base value that the object will start with."
Event1 = "This is a subset of properties that define the first of five sets of possible events."
EventValue = "This is the numeric value at which either the EventIncToValCmd or EventDecToValCmd will be sent."
EventIncToValCmd = "This is the command string that will be sent if the EventValue for this Event has been reached through incremental ascension."
EventDecToValCmd = "This is the command string that will be sent if the EventValue for this Event has been reached through incremental descent."

[Explosion]
ImpactFXName = "This is a pull down that allows you to choose the type of explosion effect that will be used."
DamageType = "This is a pull down used to identify what kind of damage will be inflicted upon anyone caught within the DamageRadius of the Explosion object when it is triggered."
DamageRadius = "This the radius measured in Dedit units in which a character will take damage from the explosion."
MaxDamage = "This field defines the maximum amount of damage that will be inflicted upon a character caught within the DamageRadius of the explosion when it is triggered."
RemoveWhenDone = "This flag toggles whether or not the explosion is removed after being triggered. Sometimes you will want to trigger an Explosion object repeatedly. In which case you would set this flag to false."

[Mine]
MoveToFloor = "This flag determines whether or not the mine object will be placed at the level of the surface below it, or if it will remain exactly where placed."
Dims = "The Dims define the 'trigger area' of the Mine object. It is an area defined in DEdit units as a box around the center of the Mine object. If the player enters this defined area, the Mine explodes."
ActivateDelay = "This is a delay in seconds between the time that the player triggers the mine, and the time that it actually explodes."

[Fire]
Radius = "This defines the outer extent of the fire effects."
StartOn = "This flag determines whether or not the Fire object begins in the on position."
Light = "This is a subset of properties that define the light effects created by the fire object."
CreateLight = "Determines whether or not a dynamic light will automatically be created for the Fire object."
LightColor = "This is the standard windows color picker dialogue that allows you to choose the color of the firelight."
LightRadius = "The falloff radius of the dynamic light in Dedit units."
LightPhase = "This specifies the phase offset of the light. Valid values are those between 0 and 360."
LightFrequency = "This value changes the rate at which the light flickers."
LightOffset = "Values will offset the position of the dynamic light created."
Sound = "This is a subset of properties that define the Sound effects created by the fire object."
CreateSound = "Determines whether or not the Fire object will play a sound."
SoundRadius = "This is the sound falloff radius in Dedit units."
Smoke = "This is a subset of properties that define the Smoke effects created by the fire object."
CreateSmoke = "This flag toggles whether or not the Fire object will create smoke effects."
SmokeOnly = "If this flag is set to true only smoke effects will be created."
BlackSmoke = "If this flag is set to true the smoke will be black instead of the default grey."
CreateSparks = "This flag toggles whether or not the fire object will create sparks."

[GameStartPoint]
GameType = "This is a dropdown that allows you to set what gameplay types this start point will be used in."
ModelTemplate = "This is a dropdown menu that allows you to choose the model player model that will be loaded at the beginning of the level."
PhysicsModel = "This dropdown menu allows you to choose what physics model is loaded at the beginning of the level."
Command	= "This is a Command string that will be processed when the player spawns in at this start point."
Locked = "This flag is used to not allow players to spawn at this start point.  Sending the GameStartPoint object LOCK and UNLOCK messages will allow or disallow players from spawning at this point."
SendCommandOnRespawn = "If this flag is set to true the Command string will be sent any time the player spawns at this point otherwise it will only be sent the first time."
Team = "This is a dropdown that allows you to set which team can spawn at this start point while playing a team game."
StartPoint = "If this flag is true players will be allowed to spawn in at this start point at the very begining of the level.  If this flag is false players won't be able to use this start point for their very first spawn into a level."
SpawnPoint = "If this flag is true players will be allowed to respawn at this start point at any point during the game after the first spawn.  If this flag is false players will not be able use this start point for respawning."

[GearItem]
GearType = "A pull down menu used to choose the type of GearItem the power up will be."

[Group]
Object1 = "This is the name of the object that will receive the command string that is sent to the Group object."

[Key]
TimeStamp = "This is the time that it takes for the KeyFramer to get to this key from the previous key in the key path."
SoundName = "The path to any .wav file may be entered here. The sound will be played when the KeyFramer arrives at this Key on the key path."
SoundRadius = "The audible range of the sound entered in the SoundName field, as measured in Dedit units."
Command = "This is a Command string that that will be processed when the KeyFramer arrives at this key."
BezierPrev = "When making a key path it is possible to create Bezier Curves. While in Object mode, if you select one of the Keys in a key path, press the P key and drag the mouse while pressing the LMB, you will pull out the Bezier handle on the 'in' side of the key. This field denotes the world coordinate position of that handle."
BezierNext = "After pulling out the first Bewzier handle, you can repeat the process to pull out the bezier handle on the 'out' side of the key. This field denotes the world coordinate position of that handle."

[KeyFramer]
ObjectName = "This feild contains the name of the object or worldmodel that is to be affected by the keyframer. This feild can contain the names of several objects and/or worldmodels seperated by semicolons."
BaseKeyName = "The base name of the keys that the KeyFramer object will follow. The first key must be named with the base name followed by 0. All subsequent keys must be named with the base name followed by two-digit increments. For example, if the BaseKeyName was 'Base', the keys would be named Base0, Base01, Base02, Base03, etc."
ExternalKeyFile = "If your animation keys are in a seperate .ltc file, exported from max, enter the file path of your animations here.  The KeyFramer will then look at the file for the keys."
PushObjects = "Determines whether or not the KeyFramer will push objects in the world."
StartActive = "If set to true, the KeyFramer will begin active."
StartPaused = "This flag works in conjunction with the StartActive flag. This flag will tell the KeyFramer to begin in the paused state if active."
Looping = "If set to true the keyframer will continuously run through the key path, returning to the first key in the sequence when reaching the last."
AlignToPath = "If set to true, the keyframer will attempt to orient, and maintain, it's forward facing vector (positive X) down the forward vector of the key path."
IgnoreOffsets = "Tells the KeyFramer whether or not to maintain offsets of position and rotation between the object being keyframed and the keys that make up the path. If set to true, the keyframed object will acquire the exact position and rotation of the keys that make up the key path."
TargetName = "You can specify a prop, worldmodel, or model in this field. The KeyFramer will attempt to continually point it's forward facing vector at this object as it travels along its key path."
TargetOffset = "You may enter a target offset in this field. It is entered in the form of x,y,z offset in Dedit units."
ActiveSound = "The path to any .wav file may be entered here. The sound will be played while the KeyFramer object is active."
SoundRadius = "The audible range of the ActiveSound entered in Dedit units."
WaveForm = "The WaveForm flag is a subset of properties that define the movement characteristics of the KeyFramer object."
TotalPathTime = "This is the approximate time in seconds that it will take for the KeyFramer object to complete it's travel down the key path."
Wavetype = "This is a dropdown list of different Waves that the KeyFramer can use while following it's path.  The KeyFramer will varry it's velocity depending on the wave type chosen."

[Light]
ClipLight = "This flag determines whether or not the light will be stopped by WorldGeometry, or pass right through."
LightObjects = "This flag determines whether or not the light will light models."
FastLightObjects = "When TRUE, this light will only cast a very simplified light on models. If it's FALSE, the light will cast more accurate light on the model."
LightRadius = "Determines the total range of the light's effects. Anything outside this range isn't lit at all by this light."
LightColor = "Determines the color of the light at the exact center of the Light object. Light falls off gradually from this center point."
OuterColor = "Determines the color of the light at the exact edge of its LightRadius. This is the color that the light fades to from its InnerColor. Can be useful if you want to stack lights together to get a special effect."
BrightScale = "A multiplier that acts like a dimmer switch. If set to 1, the light will be normal brightness. If you set to 1.5, it will be half again as bright. At 0.5, the light will be half-bright."
CastShadows = "Determines if this light will cast shadows. If false it will go through all brushes to light them."
LightAttenuation = "Controls parameters of how the light falls of at a distance. This is only valid for D3D lighting model and is commonly not changed."
ConvertToAmbient = "Specifies an amount of light from 0-1 that when lighting models will be taken out of the direct lighting and instead will ambiently light an object. This helps fill out lighting on all sides of a character."
ObjectBrightScale = "Specifies a scalar to allow increasing brightness on models. For example, if it is 1.1, it will be 10% brighter on models than the world."
Attenuation = "Specifies the attenuation method that will be used in the lighting. This controls the equation used to determine intensity as distance from the light increases."
CastShadowMesh = "Determines if this light will be used to cut up geometry when doing shadow meshing."
Size = "When doing shadow meshing this determines the diameter of the light when calculating the lighting umbra and penumbra."

[Lightning]
AlphaLifetime = "This is how long it takes to change between min and max alpha values."
Lifetime = "This value is the amount of time the Lightning remains visible on the screen."
EndPos = "These are the world coordinates where the lightning will strike. The bolt will start at the position where the object is placed, and end here."
StartOn = "This flag determines whether the lightning object begins in the on position."
OneTimeOnly = "This flag determines whether the lightning will be able to be triggered once, or repeatedly."
MinDelayTime = "This value sets the minimum amount of time between random Lightning strikes."
MaxDelayTime = "This value sets the maximum amount of time between random Lightning strikes."
Perturb = "This value sets the amount of random deviation there will be in the path of the Lightning between its origin and EndPos. Higher numbers create a wilder effect while lower numbers create a straighter bolt."
NumSegments = "This value sets the number of steps in the Lightning bolt."
PlaySound = "This flag toggles whether the Lightning object will make a sound when it is triggered."
SoundRadius = "This is the audible falloff radius for the Lightning sound measured in DEdit units."
Texture = "This field contains the .dtx file to be used as the texture for the Lightning bolt."
InnerColorStart = "The Lightning effect cross fades colors from the core to the edges of the Lightning bolt in four stages. This color would be the very core of the bolt, the first stage."
InnerColorEnd = "This would be the second stage."
OuterColorStart = "This would be the color of the third stage."
OuterColorEnd = "This would be the color of the fourth and outermost edge of the Lightning bolt."
AlphaStart = "Relative opacity at the creation point of the lightning bolt."
AlphaEnd = "Relative opacity at the end point of the lightning bolt."
Additive = "This flag toggles the use of the Additive blending mode."
Multiply = "This flag toggles the use of the Multiply blending mode."
DynamicLight = "The DynamicLight flag is a subset of properties that define the characteristics of the dynamic light created by the Lightning object."
CreateLight = "This flag determines whether or not the Lightning object will automatically create a Dynamic Light."
LightColor = "This is the color of the light that the Lightning object will create."
LightRadius = "This is the falloff radius for the Dynamic Light created by the Lightning object as measured in Dedit units."
WidthInfo = "The WidthInfo flag is a subset of properties that further define the appearance of the Lightning bolt created by the Lightning object."
MinWidth = "This field defines the width of the Lightning bolt at its narrowest point."
MaxWidth = "This field defines the width of the Lightning bolt at its widest point."
BigToSmall = "Setting this flag to true will create a Lightning bolt that begins wide, and becomes narrow at its end point."
SmallToBig = "Setting this flag to true will create a Lightning bolt that begins narrow, and becomes wide at its end point."
SmallToSmall = "Setting this flag to true will create a Lightning bolt that begins and ends narrow, becoming wide at its mid point."
Constant = "Setting this flag to true will create a Lightning bolt that maintains a constant width for the length of its travel."

[ModItem]
ModType = "A pull down menu used to choose the type of ModItem the power up will be."

[ObjectLight]
LightRadius = "Determines the total range of the light's effects. Anything outside this range isn't lit at all by this light."
FastLightObjects = "When TRUE, this light will only cast a very simplified light on models. If it's FALSE, the light will cast more accurate light on the model."
LightColor = "Determines the color of the light at the exact center of the Light object. Light falls off gradually from this center point."
OuterColor = "Determines the color of the light at the exact edge of its LightRadius. This is the color that the light fades to from its InnerColor. Can be useful if you want to stack lights together to get a special effect."
BrightScale = "A multiplier that acts like a dimmer switch. If set to 1, the light will be normal brightness. If you set to 1.5, it will be half again as bright. At 0.5, the light will be half-bright."
CastShadows = "Determines if this light will cast shadows. If false it will go through all brushes to light them."
LightAttenuation = "Controls parameters of how the light falls of at a distance. This is only valid for D3D lighting model and is commonly not changed."
ConvertToAmbient = "Specifies an amount of light from 0-1 that when lighting models will be taken out of the direct lighting and instead will ambiently light an object. This helps fill out lighting on all sides of a character."
Attenuation = "Specifies the attenuation method that will be used in the lighting. This controls the equation used to determine intensity as distance from the light increases."

[ObjectRemover]
GroupsToKeep = "This value determines how many of the groups to keep. The object will draw from the entered groups of objects and remove all but ""this"" number of groups."
Groups0and1 = "This flag is a subset of two of the groups that the ObjectRemover can choose to keep or discard."

[ParticleSystem]
ParticleLifetime = "How long will each particle last in the world after it's created?"
StartOn = "Does the particle system start when the level starts, or must it be triggered?"
ParticleFlags = "ParticleFlags determine the behavior of the particles. Some valid values are Bounce=1 (hard on performance) Shadows=2 (hard on performance) Never die=4 (hard on performance) Dumb=8 (game must update and move particles)"
Dims = "Determines the area that the particle system will affect, i.e. spawn particles in. You can use a Dims property, which will make the system cube- or –rectangle-shaped, or you could give it a Radius property instead to make it a sphere. Last, you could make it capable of binding a brush, then use the brush's shape to determine where particles will spawn."
MinVelocity = "Minimum speed a particle will have when it's created."
MaxVelocity = "Maximum speed a particle will have when it's created."
BurstWait = "A random value between BurstWaitMin and BurstWaitMax is multiplied by the BurstWait time to determine when the next burst of particles will occur."
BurstWaitMin = "See BurstWait."
BurstWaitMax = "See BurstWait."
ParticlesPerSecond = "How many particles will the system create here each second?" 
ParticleRadius = "This value determines the radius of each particle in the system.  This value is relative to the size of the texture used for the particle."
ParticleGravity = "How fast will the particles fall?" 
RotationVelocity = "This defines the velocity at which the particle system is rotated. Particle systems always rotate on their Y-axis."
MaxViewDistance = "This value sets the maximum distance at which the particles will be visible. If the camera is beyond this point, the particles will not be drawn."
Color1 = "The particles that are generated can be different colors. By specifying two colors, a color gradient will be created. The particles will be created in random colors from within this gradient. This is the first color used to define this gradient."
Color2 = "This color is the second color in the gradient used to define the color of the generated particles."
TextureName = "This field specifies the texture that is to be applied to the generated particles."

[PolyGridModifier]
Dims = "Specifies the size of the area that will be effected by this modifier. Note that the Y value is not important, and only X and Z are used."
AccelAmount = "Specifies how far this polygrid will be displaced at a given position. Note that this value is scaled by time to make it frame rate independant."
NumAccelPoints = "For every surface update, it will pick this many points to displace AccelAmount units."
StartEnabled = "Specifies whether or not this modifier should be enabled at the starting of a level."

[PolyGrid]
Ring1Rate = "Used when PlasmaType is set to 1 in the PolyGrid.  These values determine the rate at which the first, second, third, and forth plasma rings change."
XScaleDuration = "Determines the length of time the PolyGrid will take to scale between XScaleMin and XScaleMax."
Dims = "Determines the size of the grid. Polygrids normally face up (Y axis), so a typical polygrid Dims setting would be 256 8 256, for a thin grid that fills a large hole in a floor."
Color1 = "If there's no texture, you can have it blend between two colors based on height. Color1 and Color2 each bring up the color picker dialog to let you choose your two colors."
Color2 = "If there's no texture, you can have it blend between two colors based on height. Color1 and Color2 each bring up the color picker dialog to let you choose your two colors."
SpriteSurfaceName = "PolyGrids can use any sprite as a texture. This is where you enter the sprite's name."
XScaleMin = "Specifies the minimum scale that the texture used on the PolyGrid will scale to. This allows you to have the texture on the PolyGrid swim up and down in size. The number represents the number of times the texture will tile over the polygrid in the X direction"
YScaleMin = "See XScaleMin."
XScaleMax = "Specifies the maximum texture scale on the PolyGrid. See XScaleMin."
YScaleMax = "See XscaleMax."
YScaleDuration = "See XScaleDuration."
XPan = "If the PolyGrid is textured, you can enter a panning speed here to have the texture pan along the PolyGrid's X-axis. Speed is in game units/second. Typical values would be from –20 to 20 for fairly fast speed and –5 to 5 for slow."
YPan = "See XPan."
Alpha = "The translucency of the grid as a whole. If you want to use a texture without an alpha mask or fine-tune the alpha for a texture that does have an alpha mask, this is a useful property. A value of 1 is fully opaque, .5 is half-translucent and 0 is transparent."
Additive = "This flag enables the Additive blending mode."
Multiply = "This flag enables the Multiply blending mode."
NumPoliesX = "The number of segments the polygrid will have along the X direction. The higher the number of polies you add, the smoother the grid will look, but it will also take longer to render."
NumPoliesY = "The number of segments the polygrid will have along the Y direction. The higher the number of polies you add, the smoother the grid will look, but it will also take longer to render."
PlasmaInfo = "This subset of properties defines the appearance of the plasma created by the PolyGrid object."
DampenImage = "Specifies an 8 bit PCX image that can be loaded and used to control the sections of the polgrid that move. This image should be greyscale with white indicating high movement and black indicating none."
Fresnel = "Specifies whether or not this polygrid should use fresnel blending of the environment map. This will not work with dynamic lighting enabled."
Light = "Specifies if the polygrid should be dynamically lit."
SurfaceType = "Indicates the method to use to generate motion on the PolyGrid.  Valid values are 0 for normal plasma and 1 for 4 ring plasma, and 2 for they dynamic wave propagation method."
TimeScale = "A multiplier used to speed up time on the surface which causes waves to move up and down faster."
DampenScale = "A multiplier used to remove energy from the system. So if it was .95, it would use 95% of the previous energy, allowing 5% to dissappear, this prevents water simulations from exploding."
SpringCoeff = "Coefficient for the rigidness of the water springs. Raising this value will cause the water to move back into place faster, and lower will make it look more viscous."
ModelDisplace = "Specifies how much a model moving through the surface should displace. Higher values will create higher waves."
Modifier1 = "Name of a modifier that will affect the surface."
Modifier2 = "Name of a modifier that will affect the surface."
Modifier3 = "Name of a modifier that will affect the surface."
Modifier4 = "Name of a modifier that will affect the surface."
RenderEarly = "Setting this to true will cause translucent polygrids to be rendered before any other translucent objects. This can help resolve sorting issues on large shallow polygrids."

[Prop]
DebrisType = "This dropdown menu allows you to choose a type of debris that will be spawned when the Prop is destroyed."
SurfaceOverride = "This dropdown menu allows you to choose a specific surface type for the Prop."
Filename = "Specifies the .ltc file the model's geometry is in."
Skin = "Specifies the texture or textures (.DTX files) to use for the model's skin."
Scale = "This value changes the size of the object. It is a multiplicative value based on the original size of the object. You can scale an object in all three vectors independently. The default scale is 1.0 1.0 1.0."
Visible = "This property toggles the objects visibility on and off."
Solid = "This flag toggles whether or not the Prop is solid. Sometimes you want a player to be able to pass through a prop, such as low bushes or flowers in a flowerbed, without hitting or touching them."
Gravity = "Sets whether or not the selected object should fall if it's in the air. Obviously, there are times when you'd want a model to stay in the air."
Shadow = "This property determines whether the object will cast a shadow or not."
MoveToFloor = "Tells a model to appear on the floor when the level opens, even if you placed it in the air inside DEdit. Useful for objects like trees and shrubs on terrain, where it's sometimes difficult to line up the exact floor level under an object."
Alpha = "Sets overall translucency of the object, regardless of its alpha mask."
ObjectColor = "This color picker is used to add a color tint to the Prop."
Additive = "This flag enables the Additive blending mode."
Multiply = "This flag enables the Multiply blending mode."
RayHit = "This flag toggles whether or not the object will be rayhit."
DetailLevel = "This dropdown menu is used to set the detail level in which this prop will appear. For instance if you placed a Prop object and set its DetailLevel to medium, the prop would only appear if the in game detail settings were at medium or greater. A machine set to low detail would not see this object in the game."
CommandOn = "Command sent the when prop is activated on.  Prop will toggle to off if activated again."
CommandOff = "Command sent the when prop is activated off.  Prop will toggle to on if activated again."
CanTransition = "When this object is placed within a TransitionArea, it will be transitioned to the next level when a transition occurs.  Set this flag to flase if you do not want the object to transition."

[Intelligence]
ShowPopup = "This flag toggles whether or not the pop up screen for the Intelligence item is displayed."
Type = "This dropdown menu is used to select what powerup will be used to represent this particular Intelligence item."
TextId = "This field contains the Id number of the text message that is to be displayed when the player picks up this particular piece of Intelligence."
PhotoOnly = "Setting this flag to true makes this an intelligence item that can only be gathered by photographing it with the camera sunglass gadget."
PickedUpCommand = "This is the command string that is sent when the player picks up the Intelligence item."
PlayerTeamFilter = "This is a flag used to restrict the availability of an Intelligence item to a certain team. This is useful in HARM v.s. UNITY multiplayer modes."
StartHidden = "This flag toggles whether the object will begin in the hidden state."
IsIntel = "Specifies if this Intelligence item is actually a piece of Intel."
PopupId = "If ShowPopup is true, then this Id is the Id of the Popup to display.  See PopupItems.txt for the valid definitions of Popups."
RespawnTime = "The amount of time in seconds before an Intelligence item reappears after being picked up by a player."

[PlayerVehicle]
RespawnTime = "This is the amount of time before another PlayerVehicle will appear."
VehicleType = "This is a dropdown menu that allows you to choose what type of vehicle is placed."
Locked = "If set to true, players will not be able to activate the PlayerVehicle untill it is unlocked or they have the propper KeyItems.  You can lock and unlock PlayerVehicles by sending them a LOCK or UNLOCK message."
LockedCommand = "This is the command string that will be sent if a player is unable to activate the PlayerVehicle because it is locked."

[PropType]
Type = "This is a dropdown menu that allows you to choose what type of PropType is placed.  PropTypes are defined in attributes\proptypes.txt"

[SearchLight]
VisualRange = "This is the maximum range at which the SearchLight object can detect the player."
SpotTarget = "This is the name of the object that will receive the SpotMessage command string."
SpotMessage = "This is the command string that is sent when the SearchLight object spots the player."
PlayerTeamFilter = "This field allows you to set up SearchLight objects that respond to only certain teams."
Filename = "Specifies the .abc file the model's geometry is in."
Skin = "Specifies the texture or textures (.DTX files) to use for the model's skin."
DestroyedFilename = "Specifies the .abc file that contains a damaged representation of the model's geometry."
DestroyedSkin = "Specifies the texture or textures (.DTX files) to use for the skin of the damaged version of the model."
StartOn = "This flag toggles whether the SearchLight begins in the active state."
Target = "This is the field to enter the name of a keyframed object in if the SearchLight is to follow a keyframed path."
FOV = "This is the SearchLight's Field Of View."
Yaw1 = "This is the number of degrees the SearchLight will rotate in the negative direction."
Yaw2 = "This is the number of degrees the SearchLight will rotate in the positive direction."
YawTime = "This is the amount of time it takes to complete the rotation from Yaw1 to Yaw2."
Yaw1PauseTime = "This is how long the SearchLight pauses at the extent of rotation defined by Yaw1 before continuing."
Yaw2PauseTime = "This is how long the SearchLight pauses at the extent of rotation defined by Yaw2 before continuing."
SpecialFXStuff = "This is a subset of properties that define the light effects of the SearchLight object."
BeamRadius = "This value defines the size of the funnel of light at its furthest extent as measured in Dedit units."
BeamAlpha = "This value adjusts the opacity of the visible light beam."
BeamRotationTime = "This value defines how long it takes for the beam model to make one 360-degree rotation."
LightRadius = "This value defines the radius of the dynamic light automatically created by the SearchLight object. The radius is entered in Dedit units."
LightColor = "Determines the color of the light at the exact center of the Light object. Light falls off gradually from this center point."
BeamAdditive = "This flag toggles the use of additive blending by the visible beam model."
LensFlareProps = "This is a subset of properties that define the Sprite effects associated with the SearchLight object."
CreateSprite = "This flag toggles whether the SearchLight object will automatically create a ScaleSprite object."
UseObjectAngle = "This property was not used in the creation of NOLF and is not supported."
MinSpriteAlpha = "This is the minimum sprite alpha value. This is the alpha when the SearchLight is pointed away from the camera."
MaxSpriteAlpha = "This is the sprite alpha value for when the SearchLight is shining at the camera."
SpriteAdditive = "This flag toggles Additive blending."
SpriteFile = "This field points to the .spr file that will be used as the flare for the SearchLight."
MinAngle = "This is the minimum angle between the camera and the sprite where the sprite is still visible."
SpriteOffset = "An offset value from the SearchLight object down its forward facing vector."
MinSpriteScale = "This is the scale of the sprite when it is at MinAngle."
MaxSpriteScale = "This is the scale of the sprite when it is facing the camera."
BlindingFlare = "This flag toggles whether or not the SearchLight object will automatically create a BlindingFlare."
BlindObjectAngle = "This is the angle between the searchlight's forward vector and the vector between the camera's position and the search light's position - When this angle is less the value supplied the 'blind' sprite will become visible and scale between MinBlindScale and MaxBlindScale as this value goes to 0.0."
BlindCameraAngle = "This is the angle between the camera's forward vector and the vector between the camera's position and the search light's position - When this angle is less the value supplied (and the BlindObjectAngle condition is met) the 'blind' sprite will become visible and scale between MinBlindScale and MaxBlindScale."
MinBlindScale = "This is the minimum scale of the blinding sprite."
MaxBlindScale = "This is the maximum scale of the blinding sprite."

[SecurityCamera]
SpotCommand = "This is the command string that is sent when the SearchLight object spots the player."
PlayerTeamFilter = "This field allows you to set up SearchLight objects that respond to only certain teams."
Filename = "Specifies the .abc file the model's geometry is in."
Skin = "Specifies the texture or textures (.DTX files) to use for the model's skin."
DestroyedFilename = "Specifies the .abc file that contains a damaged representation of the model's geometry."
DestroyedSkin = "Specifies the texture or textures (.DTX files) to use for the skin of the damaged version of the model."
Yaw1 = "This is the number of degrees the SearchLight will rotate in the negative direction."
Yaw2 = "This is the number of degrees the SearchLight will rotate in the positive direction."
YawTime = "This is the amount of time it takes to complete the rotation from Yaw1 to Yaw2."
FOV = "This is the SearchLight's Field Of View."
VisualRange = "This is the maximum range at which the SearchLight object can detect the player."
Yaw1PauseTime = "This is how long the SearchLight pauses at the extent of rotation defined by Yaw1 before continuing."
Yaw2PauseTime = "This is how long the SearchLight pauses at the extent of rotation defined by Yaw2 before continuing."
SoundRadius = "This is the audible falloff range of all of the cameras actions as measured in Dedit units."

[RandomSpawner]
Spawner = "This field contains the base spawner name (i.e. spawner, where the spawners are named Spawner00, Spawner01, etc)."
Number = "This sets the number of things to spawn."

[ScaleSprite]
DamagedFilename = "Each ScaleSprite can display three different .spr files that represent three stages damage. This would display a damaged version of the .spr entered in the FileName field."
DestroyedFilename = "This would be the third .spr displayed. It would represent the destroyed version of the .spr entered in the FileName field."
ZBias = "Helps some sprites to not clip into world geometry as much."
Filename = "Specifies the name of the sprite file (*.spr) that the ScaleSprite object will display."
StartOn = "This flag defines whether the ScaleSprite is to begin in the on state."
Dims = "Dims specifies the bounding box (dimensions) of the object.  The box is relative to the position of the object.  When two object's dims are overlapping the objects are considered touching."
Color = "This is the standard windows color picker dialogue. The color chosen tints the color of the ScaleSprite."
Alpha = "Sets the base alpha value of the sprite, independent of the value of the sprite's alpha mask. Changing the alpha value will alter the ScaleSprites opacity."
ScaleX = "Sets the overall size of the Sprite in the X-axis. A scale of 1 would set it to its size in pixels; .5 would display it as half the size in pixels."
ScaleY = "Sets the overall size of the Sprite in the Y-axis. A scale of 1 would set it to its size in pixels; .5 would display it as half the size in pixels."
AdditionalFlags = "This is a subset of properties that further define the appearance of the ScaleSprite."
FlushWithWorld = "If this flag is set to true the ScaleSprite will be projected down the negative Z-axis onto any geometry."
Rotatable = "If set to TRUE the sprite will use the object's rotation for orientation.  If set to FALSE the sprite will always face the camera."
Glow = "This flag determines whether the ScaleSprite will scale as the viewing angle and distance changes."
Additive = "This flag toggles the Additive blend mode."
Multiply = "This flag toggles the Multiply blend mode."
LensFlareProps = "This flag is a subset of properties that further define the appearance of the ScaleSprite object."
CreateSprite = "Toggles the creation of the blinding flare."
UseObjectAngle = "This property is not used and is always set to true."
MinAngle = "Minimum angle between the camera and the sprite where the sprite is still visible."
SpriteOffset = "Offset away from the ScaleSprites position along the ScaleSprites forward facing vector, that the sprite for the BlindingFlare is created."
MinSpriteAlpha = "The minimum alpha for the BlindingFlare attached to the ScaleSprite. The value when the ScaleSprite is seen through the corner of the eye."
MaxSpriteAlpha = "The maximum alpha for the BlindingFlare attached to the ScaleSprite. The value when the ScaleSprite is viewed directly."
MinSpriteScale = "The minimum scale for the BlindingFlare attached to the ScaleSprite. The value when the ScaleSprite is seen through the corner of the eye."
MaxSpriteScale = "The maximum scale for the BlindingFlare attached to the ScaleSprite. The value when the ScaleSprite is viewed directly."
SpriteFile = "This field points to the .spr file that will be used as the flare for the SearchLight."
BlindingFlare = "This flag toggles whether or not the ScaleSprite object will automatically create a BlindingFlare."
BlindObjectAngle = "The angle between the ScaleSprites forward vector and the vector between the camera’s position and the ScaleSprites position - When this angle is less the value supplied the blind sprite will become visible and scale between MinBlindScale and MaxBlindScale as this value goes to 0.0 - Note both BlindObjectAngle’s and BlindCameraAngle’s conditions must be met for the blind sprite to appear."
BlindCameraAngle = "The angle between the camera’s forward vector and the vector between the camera’s position and the search light’s position. When this angle is less the value supplied (and the BlindObjectAngle condition is met) the blind sprite will become visible and scale between MinBlindScale and MaxBlindScale."
MinBlindScale = "The size of the BlindingFlare when it is at its smallest."
MaxBlindScale = "The size of the BlindingFlare when it is at its largest."
SpriteAdditive = "This flag toggles Additive blending."

[ScreenShake]
Amount = "This property defines the amount to shake in x, y, and z – that the camera will shake until the values decay to zero in all 3 axis...(max value is 20, good values are less than 3)."
NumShakes = "The number of times the shake occurs (leave -1 to control via on/off trigger)."
Frequency = "This value defines how often a shake occurs.  Every 'frequency' seconds a shake will occur if the ScreenShake object is active (i.e., an ON message has been sent to it)."
AreaOfEffect = "This value defines how close the player needs to be to the object to feel the screen shake (leave -1 for the entire level)."
ShakeSound = "The path to any .wav file may be entered here. This sound file is played EVERY time a shake occurs (i.e., every frequency seconds)."
SoundRadius = "This is the radius of the sound falloff measured in Dedit units."

[SkyPointer]
SkyObjectName = "The name of the object that you want this SkyPointer to render in the sky."
SkyDims = "Takes the X, Y and Z dimensions of the SkyPointer. These need to be large enough to encompass all geometry that you plan to show in your skybox if you want it to appear in the sky. Only one object per level should have its Dims set."
Flags = "This property was not used in the creation of NOLF and is not supported."
Index = "The object's index determines the order in which it's drawn. Objects with low Index values are rendered first (and thus at the back), while objects with a higher index are rendered last and at the front."
InnerPercentX = "Determines the amount of player motion that's passed on to the camera rendering the sky. If the value is set to 0.100, only ten percent of the player's movement will be passed on to the camera. Camera movement is used to simulate parallax movement of objects in the sky. Be sure that if you give the cameras a lot of motion, you'll need to make your skybox large enough that the camera doesn't move outside it."
InnerPercentY = "See InnerPercentX."
InnerPercentZ = "See InnerPercentX."

[SoundFX]
StartOn = "This flag toggles the sound to start in the on state."
Sound = "The path to any .wav file may be entered here. This sound file will be played when the SoundFX object is triggered on."
SoundRadius = "This is the radius of the sound falloff measured in Dedit units."
Priority = "You can assign Priority values to SoundFX objects so that some sounds will take priority over others. The valid values are 0, 1, and 2. Lower numbers have lower priority."
InnerRadius = "It's useful and simple to give a sound two radii, one Inner where it plays at full Volume, and one Outer where it plays at a reduced volume. It's a cheap way of having a sound fade over distance without requiring possibly expensive audio processing in-game. The values a set in Dedit units."
OuterRadius = "See InnerRadius."
Volume = "This value is expressed as a percentage. It is how loud the sound is at its origin point."
PitchShift = "This value speeds up or slows down the file.  You can set a different pitch with this property to make it play lower or higher in pitch.  1.00 is normal pitch, 1.10 would be pitched up 10%, 0.90 would be 10% pitched down.  It does this by changing the playback sample rate of the file."
Ambient = "Setting Ambient to TRUE means that the sound will play as if it were coming from everywhere around you, but will get quieter as you move farther away from it.  Setting Ambient to FALSE means that the sound will play from a specific point."
Loop = "This flag toogles whether the sound will loop continuously or play only once when triggered on."
PlayAttached = "Setting this flag to true will allow its origin point to move. This flag is useful if the sound is to be attached to a moving object."
Filter = "Every sound played in NOLF may have some type of software filtering done to it before it is passed off to the sound card.  The current implementation allows sounds to independently specify what filter they use when they are played, or (by default) use the 'dynamic' filter associated with the current listener (camera) position.  Also sounds can specify that they do not want to be filtered."

[Spawner]
DefaultSpawn = "This field defines a string of properties defining an object to be spawned in when the Spawner receives a 'default' command."
Target = "This field defines what object template is to be spawned in when the Spawner receives a 'spawn' command."
SpawnSound = "The path to any .wav file may be entered here. This sound file will be played when the Spawner object is triggered."
SoundRadius = "This is the radius of the sound falloff measured in Dedit units."
InitialCommand = "Command run after object is spawned.  The default target of the command is the new object."

[Speaker]
SoundRadius = "This is the radius of the sound falloff measured in Dedit units."
Attachments = "Not used in the creation of NOLF2 and is unsupported."

[StaticSunLight]
Rotation = "Sets the angle of the light that falls into the level."
InnerColor = "Sets the color of the light emitted by the StaticSunLight, just like a normal light."
BrightScale = "Sets the brightness of the StaticSunLight, just like a normal light."
ConvertToAmbient = "Specifies an amount of light from 0-1 that when lighting models will be taken out of the direct lighting and instead will ambiently light an object. This helps fill out lighting on all sides of a character."
ObjectBrightScale = "Specifies a scalar to allow increasing brightness on models. For example, if it is 1.1, it will be 10% brighter on models than the world."

[TeleportPoint]
MoveToFloor = "This flag determines whether the object moved to this point will have the bottom of their bounding box aligned with the floor."

[Trigger]
Dims = "The dimensions of the trigger in the game. If the player has to walk into the trigger to fire it, you should set the dimensions. If the trigger is fired off by another object, then they don't need to be changed. Trigger dimensions are set as x, y and z values. You can make each of them as small as 0 or as large as you need. For example, for a trigger that fills a typical doorway you would set the dims to 128 128 4. Using the 4 is just to make the object easier to find. Triggers can be any size."
NumberOfActivations = "This value sets how many times the Trigger object can be activated. Setting this value to 0 allows the Trigger to be activated an infinite number of times."
SendDelay = "A specified amount of seconds between the time the Trigger object receives a trigger message, and the when it sends its command strings."
TriggerDelay = "After being triggered, this is the amount of time before the Trigger object can be activated again."
Commands = "This is a subset of properties that are command strings the trigger object will process when triggered."
Command0 = "These are the command strings that will be sent."
TriggerTouch = "Not used in the creation of NOLF2 and is unsupported."
CommandTouch = "Not used in the creation of NOLF2 and is unsupported."
PlayerTriggerable = "This flag toggles whether or not the players bounding box intersecting that of the Trigger will activate it."
PlayerKey = "If the trigger is PlayerTriggerable this property is used to specify if the player needs a specific KeyItem to trigger the trigger."
AITriggerable = "This flag toggles whether or not an AIs bounding box intersecting that of the Trigger will activate it."
AITriggerName = "Triggers that are set to be AI triggerable can be set up to only respond to a specific AI. Enter the name of the specific AI that you want to activate the trigger in this field."
BodyTriggerable = "This flag toggles whether a trigger can be triggered by bodies."
BodyTriggerName = "This is used to specify the name of a specific body that will be allowed to trigger the trigger."
WeightedTrigger = "Not used in the creation of NOLF2 and is unsupported."
Message1Weight = "Not used in the creation of NOLF2 and is unsupported."
TimedTrigger = "If this flag is set to true the Trigger object will continue to send its messages repeatedly based on the minimum and maximum times set in the MinTriggerTime and MaxTriggerTime fields."
MinTriggerTime = "If the trigger's TimedTrigger flag is set to true, this value will set the shortest delay before the trigger fires."
MaxTriggerTime = "If the trigger's TimedTrigger flag is set to true, this value will set the longest delay before the trigger fires."
ActivationCount = "This field is used to set an activation threshold. The Trigger object will need to receive a number of 'trigger' messages equal to the value entered in this field before its messages will be sent."
Locked = "This property can be used if you only want to be able to trip the trigger after a certain event has happened. You would also need a Condition variable, or Unlock messages on the objects that can unlock the trigger."
ActivationSound = "Specifies a sound file to play when the trigger fires. If you want a player to know that they've just set something off, found a clue or entered a cut scene, this can be useful."
SoundRadius = "Determines the distance from the trigger that you can hear the ActivationSound play, if it has one."
AttachToObject = "Attaches a Trigger to an object, such as a Prop or a WorldModel. If the object moves, so does the trigger."
PlayerTeamFilter = "This flag allows you to make triggers that can only be activated by specific teams."
HUDLookAtDist = "If this is greater than 0, a HUD icon indicating that the player is close to the trigger will appear when the player is looking at the trigger and is this distancs away from the dims of the object."
HUDAlwaysOnDist = "If this is greater than 0, a HUD icon indicating that the player is close to the trigger will appear when the player is this distance away form the center of the object."
TriggerType = "A dropdown list of 'TriggerTypes' from TriggerTypes.txt.  Selecting a TriggerType will display the icon specified in the text file when the player is within the HUDLookAtDist and HUDAlwaysOnDist.  Selecting <none> will display no icon."

[ExitTrigger]
FadeOutTime = "This is the time in seconds that it takes for the camera to fade to black once the trigger has been activated."
ExitMission = "Exit trigger will load the first level of the next mission."

[VolumeBrush]
Visible = "This flag sets whether the brush that makes up the volume is visible or not."
Hidden = "This flag allows you to make a volume begin hidden in the level. Later you can send a (hidden 0) message to the VolumeBrush object to unhide it."
Viscosity = "This value affects the resistance of the players movement through the volume."
Friction = "This property allows you to alter the friction coefficient of surfaces to create slippery surfaces."
Current = "This is a force that pushes against the player. Use positive or negative values along each axis (x, y, and z) to indicate the direction and strength of the current. In general, you'll need values in the thousands in order to lift a player off the ground. This works well to create moving streams or areas of rushing wind."
Damage = "Sets amount of damage dealt by this area for every second the player is in it."
DamageType = "This is a dropdown menu that allows you to choose the damage type that will be inflicted by the Volume."
TintColor = "You can define a tint for the player's view if you want the area to look as if it's filled with light or liquid."
LightAdd = "This allows you to further alter the view from inside a Volume."
SoundFilter = "You could have sound behave differently inside the volume. In the case of liquid, you could mute out high frequencies. In the case of a dimensional gate, you might add a strange echo or other filter."
CanPlayMovementSounds = "This flag disables the footstep sounds and head-bob motion in a volume."
FogStuff = "This is a subset of properties that define the fog effects that will be seen when the player is within the Volume Brush."
FogEnable = "This flag toggles the fog effects on and off."
FogFarZ = "This is a value that determines at what distance the fog reaches full saturation."
FogNearZ = "This value determines at what distance the fog is at zero saturation."
FogColor = "This color picker determines the color of the fog effect."
SurfaceOverride = "This dropdown menu allows you to choose a specific surface type for the VolumeBrush."

[PickupItem]
Scale = "This value changes the size of the object. It is a multiplicative value based on the original size of the object. You can scale an object in all three vectors independently. The default scale is 1.0 1.0 1.0."
Visible = "This property toggles the objects visibility on and off."
Shadow = "This property determines whether the object will cast a shadow or not."
PickupCommand = "This is the command that is sent when the player picks up the WeaponItem."
Rotate = "Not used in the creation of NOLF2 and is unsupported."
Bounce = "Not used in the creation of NOLF2 and is unsupported."
RespawnSound = "Sound file that is played when the item powerup respawns."
PickupSound = "Sound file that is played when the item powerup is picked up."
MoveToFloor = "Whether or not the object is moved to the floor when created in the game."
SPRespawn = "Singleplayer: Item will respawn in RespawnTime."
MPRespawn = "Multiplayer: Item will respawn in RespawnTime."
RespawnTime = "The amount of time in seconds before a powerup reappears after being picked up by a player."
UseModelOverride = "If set to true, the PropType chosen in ModelOverride will be used to override the default mode."
ModelOverride = "Contains a list of PropType objects that can be used to override the default model."
WorldAnimation = "Specifies the name of the animation to use for the model.  The default 'World' animation is typically lying flat on the ground.  The 'BinPos' animation should be an animation created in model edit with the 'Create anim from Bind Pose' menu option.  The model that is visible in DEdit is using the models bind pose so setting this property to 'BindPos' will allow LD's to rotate the model and have it look exactly the same in game as it does in DEdit."
Team = "This is a dropdown list that allows you to specify if a team owns this item.  Only players on the owning team will be able to pickup this item.  If NoTeam is selected then all players can pickup the item."  

[WeaponItem]
WeaponType = "A pull down menu used to choose the type of WeaponItem the power up will be."
AmmoAmount = "This value determines the amount of ammunition that the weapon will have. A value of -1 will use the default amounts set in the attribute file."

[WorldProperties]
FarZ = "This value sets the distance of the farZ-clipping plane for the level."
AllSkyPortals = "If this is set to 1, the engine will not use the vis for sky portal polies, but instead it will process ALL sky portal polies in the level to determine where it should draw the sky."
Wind = "Not used in the creation of NOLF2 and is unsupported."
EnvironmentMap = "Not used in the creation of NOLF2 and is unsupported."
GlobalSoundFilter = "This field allows you to choose a sound filter that will be used for the entire level."
FogInfo = "This is a subset of properties that define the overall fogging effects for the entire level."
FogEnable = "This flag toggles the fog effects on and off."
FogColor = "This color picker determines the color of the fog effect."
FogNearZ = "This value determines at what distance the fog is at zero saturation."
FogFarZ = "This is a value that determines at what distance the fog reaches full saturation."
SkyFogEnable = "This flag toggles the SkyFog effects on and off."
SkyFogNearZ = "This value determines at what distance the fog is at zero saturation."
SkyFogFarZ = "This is a value that determines at what distance the fog reaches full saturation."
VFogInfo = "Not used in the creation of NOLF2 and is unsupported."
VFog = "Not used in the creation of NOLF2 and is unsupported."
VfogMinY = "Not used in the creation of NOLF2 and is unsupported."
VfogMaxY = "Not used in the creation of NOLF2 and is unsupported."
VfogMinYVal = "Not used in the creation of NOLF2 and is unsupported."
VfogMaxYVal = "Not used in the creation of NOLF2 and is unsupported."
VfogDensity = "Not used in the creation of NOLF2 and is unsupported."
VfogMax = "Not used in the creation of NOLF2 and is unsupported."
SkyPanning = "Not used in the creation of NOLF2 and is unsupported."
PanSkyTexture = "Not used in the creation of NOLF2 and is unsupported."
PanSky = "Not used in the creation of NOLF2 and is unsupported."
PanSkyOffsetX = "Not used in the creation of NOLF2 and is unsupported."
PanSkyOffsetZ = "Not used in the creation of NOLF2 and is unsupported."
PanSkyScaleX = "Not used in the creation of NOLF2 and is unsupported."
PanSkyScaleZ = "Not used in the creation of NOLF2 and is unsupported."
TimeOfDay = "Not used in the creation of NOLF2 and is unsupported."
MusicControlFile = "This sets the path to the .txt control file that sets up the direct music files to be used for the level."
LMAnimStatic = "Not used in the creation of NOLF2 and is unsupported."
ShadowMinColorComponent = "This value allows nearly invisible shadows to not be rendered. It can range from 0-255 with 0 causing all shadows to show up, and 255 causing none."
ShadowMaxProjDist = "Specifies the maximum distance from the center of the model casting the shadow that the shadow can extend."
ShadowAlpha = "A scale for the alpha component of the shadow. Setting it less than one lightens shadows, more than 1 darkens them."
AIMaxNumber = "Maximum number of existing AI that are allowed.  Spawned AI will fail to spawn if this max is already reached.  Level placed AI are unaffected."
VehicleMaxNumber = "Maximum number of existing PlayerVehicles that are allowed."
LevelEndCmd = "Command sent when the level ends."
ClampFarZ = "If set to true the FarZ will be calamped to the FogFarZ and the diminsions of the world."

[Alarm]
ActivateTarget = "This is the name of the object that will receive the ActivateMesage command string."
PlayerUsable = "This flag toggles whether the player is able to activate the alarm."
ActivateMessage = "This is the command string that is sent when the Alarm object is activated."
Visible = "Is the alarms model visible?"
AlertRegions = "AI in these AIRegions will go alert but will not run to the alarm."
RespondRegions = "AI in these AIRegions will run to the alarm."
SearchRegions = "After responding to this alarm, AI will search these AIRegions."
PlayerActivateCommand = "This is the command string that is sent when the Alarm is activated by a player."
SoundTime = "This allows you to specify the amount of time, in seconds, that the Alarm is active."

[CCharacter]
HitPoints = "Number of hit points before death."
MoveToFloor = "Should the character move to the floor at the start of the level?"
MakeBody = "Make a body after death."
PermanentBody = "Don't remove body when doing body density capicity limiting."
BodyLifetime = "How long the body will remain visible after being created.  -1 for infinite lifetime."
HeadExtension = "You can specify a different head skin to use for this Character.  Entering a number 1-3 will look for a head skin that is named the default skin with the number added to it (ex. DefaultHeadSkin2.dtx).  If RANDOM is entered one of the AltHeadSkin# specified for the model in modelbutes.txt will be randomly picked."
SpawnItem = "Spawn string to run after death."
AddChildModel = "This is a group of properites that allows you to specify child models that should be added to the Character model."
ChildModel_1 = "Child model to load."
ChildModel_2 = "Child model to load."
ChildModel_3 = "Child model to load."
GeneralInventory = "Not used in the creation of NOLF2 and is unsupported."
Attachments = "This is a subset of properties that allow you to assign attachments to certain parts of the Character's body."

[CAI]
CinematicExtension				= "Not used in the creation of NOLF2 and is unsupported."
BodySkinExtension				= "You can specify a different body skin to use for this Character.  Entering a number 1-3 will look for a body skin that is named the default skin with the number added to it (ex. DefaultBodySkin2.dtx).  If RANDOM is entered one of the AltBodySkin# specified for the model in modelbutes.txt will be randomly picked."
SoundRadius						= "The volume of any that AI the sound plays. Outside of this radius, the sound will not be audible. [DEdit units]"
Accuracy						= "The amount of error in an AI's shots. 0.0 to 1.0 is least to most accurate."
Lag								= "The amount of time it takes an AI's fire to zero in on you once it has started shooting."
Awareness						= "A modifier that affects the rate at which AI's react to stimuli. 0.0 to 1.0 will double to halve their reaction time."
Commands						= "This is a subset of properties that are command strings that will be sent on certain conditions."
Initial							= "A command that is sent when the level starts."
ActivateOn						= "A command that is sent when the AI's activation is toggled on."
ActivateOff						= "A command that is sent when the AI's activation is toggled off."
OnMarkingCommand                = "Not used in the creation of NOLF2 and is unsupported."
ProximityGoalCommand            = "Command run from AIGoalProximityCommand when AI is close enough to a target."
CanSeeEnemy						= "Controls whether the AI's SeeEnemy sense is enabled. [TRUE/FALSE]"
SeeEnemyDistance				= "The maximum distance at which the SeeEnemy sense will preceive stimuli. [DEdit units]"
CanSeeAllyDeath					= "Controls whether the AI's SeeAllyDeath sense is enabled. [TRUE/FALSE]"
SeeAllyDeathDistance			= "The maximum distance at which the SeeAllyDeath sense will preceive stimuli. [DEdit units]"
CanHearAllyDeath				= "Controls whether the AI's HearAllyDeath sense is enabled. [TRUE/FALSE]"
HearAllyDeathDistance			= "The maximum distance at which the HearAllyDeath sense will preceive stimuli. [DEdit units]"
CanHearAllyPain					= "Controls whether the AI's HearAllyPain sense is enabled. [TRUE/FALSE]"
HearAllyPainDistance			= "The maximum distance at which the SeeAllyPain sense will preceive stimuli. [DEdit units]"
CanSeeEnemyFlashlight			= "Controls whether the AI's SeeEnemyFlashlight sense is enabled. [TRUE/FALSE]"
SeeEnemyFlashlightDistance		= "The maximum distance at which the SeeEnemyFlashlight sense will preceive stimuli. [DEdit units]"
CanSeeEnemyFootprint			= "Controls whether the AI's SeeEnemyFootprint sense is enabled. [TRUE/FALSE]"
SeeEnemyFootprintDistance		= "The maximum distance at which the SeeEnemyFootprint sense will preceive stimuli. [DEdit units]"
CanHearEnemyFootstep			= "Controls whether the AI's HearEnemyFootstep sense is enabled. [TRUE/FALSE]"
HearEnemyFootstepDistance		= "The maximum distance at which the HearEnemyFootstep sense will preceive stimuli. [DEdit units]"
CanHearEnemyDisturbance			= "Controls whether the AI's HearEnemyDisturbance sense is enabled. [TRUE/FALSE]"
HearEnemyDisturbanceDistance	= "The maximum distance at which the HearEnemyDisturbance sense will preceive stimuli. [DEdit units]"
CanHearEnemyWeaponImpact		= "Controls whether the AI's HearEnemyWeaponImpact sense is enabled. [TRUE/FALSE]"
HearEnemyWeaponImpactDistance	= "The maximum distance at which the HearEnemyWeaponImpact sense will preceive stimuli. [DEdit units]"
CanHearEnemyWeaponFire			= "Controls whether the AI's HearEnemyWeaponFire sense is enabled. [TRUE/FALSE]"
HearEnemyWeaponFireDistance		= "The maximum distance at which the HearEnemyWeaponFire sense will preceive stimuli. [DEdit units]"
CanHearAllyWeaponFire			= "Controls whether the AI's HearAllyWeaponFire sense is enabled. [TRUE/FALSE]"
HearAllyWeaponFireDistance		= "The maximum distance at which the HearAllyWeaponFire sense will preceive stimuli. [DEdit units]"
UseDefaultAttachments			= "If true the default attachments that are specified in modelbutes.txt will be used."
HolsterWeapons					= "If true the weapons will be holstered when the AI spawns."
IsCinematicAI					= "If the AI is only going to be used in a cinematic scene then set this flag to true."
CanTalk							= "If the AI is going to talk then set this flag to true."

[CAIHuman]
CreepSpeed						= "The speed at which the AI creeps. (Not used)"
WalkSpeed						= "The speed at which the AI walks. [DEdit units/second]"
SwimSpeed						= "The speed at which the AI swims. [DEdit units/second]"
RunSpeed						= "The speed at which the AI runs. [DEdit units/second]"
RollSpeed						= "The speed at which the AI rolls. (Not used)"
Lighter							= "A command that is sent when the AI is activated with the lighter gadget."
Brain							= "The name of a the brain template that will be used by the AI. (Defined in AIButes.txt)"
ModelTemplate                   = "The name of the model template in modelbutes.txt."
GoalSet                         = "The name of the goalset in aigoals.txt."
OnMarkingCommand                = "Do NOT use for TO2."
ProximityGoalCommand            = "Command run from AIGoalProximityCommand when AI is close enough to a target."
UseDefaultAttachments			= "If true the default attachments that are specified in modelbutes.txt will be used."
HolsterWeapons					= "If true the weapons will be holstered when the AI spawns."

[AINode]
Face							= "Set this to true if you want the AI who uses this node to face along the forward of the node."
Alignment						= "This is a dropdown list that allows you to set the allignment of the AINode.  Only AI that are of the same allignment are able to use the node."
StartDisabled					= "If true the AINode will begin disabled."

[AINodeCover]
Duck = "Indicates whether ducking cover is available at this node."
BlindFire = "Indicates whether blind fire cover is available at this node."
1WayRoll = "Indicates whether 1 way cornering is available at this node. (Same as 1WayStep)"
2WayRoll = "Indicates whether 2 way cornering is available at this node. (Same as 2WayStep)"
1WayStep = "Indicates whether 1 way cornering is available at this node. (Same as 1WayRoll)"
2WayStep = "Indicates whether 2 way cornering is available at this node. (Same as 2WayRoll)"
IgnoreDir = "Should the AI ignore the threat FOV on this cover node?"
Fov = "The AI's threat must be within this FOV of the forward vector of the node for it to be valid cover. [Degrees]"
Radius = "The AI must be within this radius to be able to use the node. [DEdit units]"
ThreatRadius = "If the AI's threat comes within this radius of the cover node, it will execute the ThreatRadiusReaction. [DEdit units]"
ThreatRadiusReaction = "A command that is sent when the AI's threat has penetrated the ThreatRadius."
Object = "The name of an object that will be sent a 'TRIGGER' message when the AI arrives at the node. Used for flipping over tables, etc."
Timeout = "After spending this much time at the cover node, the AI will perform the execute the TimeoutCmd [seconds]."
TimeoutCmd = "The command that is sent when the TimeOut time on the cover node has been exceeded by the AI using the node."
DamageCmd = "The command that is sent when an AI *in cover* at the cover node receives damage (since he believes he should be protected.)"
HitpointsBoost = "A multiplier against which the AI's hitpoints are multiplied when the AI is using the cover. When the AI leaves the cover, its hitpoints will be divided by this value."

[AINodeVantage]
IgnoreDir = "Should the AI ignore the threat FOV on this vantage node?"
Fov = "The AI's threat must be within this FOV of the forward vector of the node for it to be valid cover. [Degrees]"
Radius = "The AI must be within this radius to be able to use the node. [DEdit units]"
ThreatRadius = "If the AI's threat comes within this radius of the vantage node, it will execute the ThreatRadiusReaction. [DEdit units]"
ThreatRadiusReaction = "A command that is sent when the AI's threat has penetrated the ThreatRadius."
DamageCmd = "The command that is sent when an attacking AI at the vantage node receives damage."

[AINodeSearch]
ShineFlashlight = "Indicates whether the AI can shine his flashlight at this search node."
LookUnder = "Indicates whether the AI can play the look under animation at this search node."
LookOver = "Indicates whether the AI can play the look over animation at this search node."
LookLeft = "Indicates whether the AI can play the look left animation at this search node."
LookRight = "Indicates whether the AI can play the look right animation at this search node."
Alert1 = "Indicates whether the AI can play the alert1 animation at this search node."
Alert2 = "Indicates whether the AI can play the alert2 animation at this search node."
Alert3 = "Indicates whether the AI can play the alert3 animation at this search node."

[AINodePanic]
Stand = "Indicates whether the AI can stand at this panic node."
Crouch = "Indicates whether the AI can crouch at this panic node."
Radius = "The AI must be within this radius to be able to use the node. [DEdit units]"
Object = "The name of an object that will be sent a 'TRIGGER' message when the AI arrives at the node. Used for flipping over tables, etc."

[AINodeUseObject]
Object = "The name of the object that the AI is to use. Must be an Alarm or Switch object."
Radius = "The AI must be within this radius to be able to use the node. [DEdit units]"

[AINodePickupObject]

Object = "The name of the object that the AI is to pick up. Must be a WeaponItem."
Radius = "The AI must be within this radius to be able to use the node. [DEdit units]"

[AINodeBackup]

Cmd = "The command that gets sent when the AI reaches the node."
Radius = "The AI must be within this radius to be able to use the node. [DEdit units]"

[AINodeTraining]
	
Cmd = "The command that gets sent when the AI uses the Training node."
Radius = "The AI must be within this radius to be able to use the node. [DEdit units]"

[AINodeTrainingFailure]

[AINodeTrainingSuccess]

[AINodePoodle]

[AINodeBark]

Cmd = "The command that gets sent when the dog enters in the barking state and uses the node."

[AINodeTail]

[AINodeDive]

[AINodePatrol]

Next = "The name of the next node on the patrol path."
Action = "The action to perform at the node while patrolling."
Face = "Whether the AI should face along the forward vector of the node when it arrives there."

[AIRegion]

Volume1  = "The name of a volume that is a member of the AIRegion."
Volume2  = "The name of a volume that is a member of the AIRegion."
Volume3  = "The name of a volume that is a member of the AIRegion."
Volume4  = "The name of a volume that is a member of the AIRegion."
Volume5  = "The name of a volume that is a member of the AIRegion."
Volume6  = "The name of a volume that is a member of the AIRegion."
Volume7  = "The name of a volume that is a member of the AIRegion."
Volume8  = "The name of a volume that is a member of the AIRegion."
Volume9  = "The name of a volume that is a member of the AIRegion."
Volume10 = "The name of a volume that is a member of the AIRegion."
Volume11 = "The name of a volume that is a member of the AIRegion."
Volume12 = "The name of a volume that is a member of the AIRegion."
Volume13 = "The name of a volume that is a member of the AIRegion."
Volume14 = "The name of a volume that is a member of the AIRegion."
Volume15 = "The name of a volume that is a member of the AIRegion."
Volume16 = "The name of a volume that is a member of the AIRegion."
Volume17 = "The name of a volume that is a member of the AIRegion."
Volume18 = "The name of a volume that is a member of the AIRegion."
Volume19 = "The name of a volume that is a member of the AIRegion."
Volume20 = "The name of a volume that is a member of the AIRegion."
Volume21 = "The name of a volume that is a member of the AIRegion."
Volume22 = "The name of a volume that is a member of the AIRegion."
Volume23 = "The name of a volume that is a member of the AIRegion."
Volume24 = "The name of a volume that is a member of the AIRegion."
Volume25 = "The name of a volume that is a member of the AIRegion."
Volume26 = "The name of a volume that is a member of the AIRegion."
Volume27 = "The name of a volume that is a member of the AIRegion."
Volume28 = "The name of a volume that is a member of the AIRegion."
Volume29 = "The name of a volume that is a member of the AIRegion."
Volume30 = "The name of a volume that is a member of the AIRegion."
Volume31 = "The name of a volume that is a member of the AIRegion."
Volume32 = "The name of a volume that is a member of the AIRegion."
Volume33 = "The name of a volume that is a member of the AIRegion."
Volume34 = "The name of a volume that is a member of the AIRegion."
Volume35 = "The name of a volume that is a member of the AIRegion."
Volume36 = "The name of a volume that is a member of the AIRegion."
Volume37 = "The name of a volume that is a member of the AIRegion."
Volume38 = "The name of a volume that is a member of the AIRegion."
Volume39 = "The name of a volume that is a member of the AIRegion."
Volume40 = "The name of a volume that is a member of the AIRegion."
Volume41 = "The name of a volume that is a member of the AIRegion."
Volume42 = "The name of a volume that is a member of the AIRegion."
Volume43 = "The name of a volume that is a member of the AIRegion."
Volume44 = "The name of a volume that is a member of the AIRegion."
Volume45 = "The name of a volume that is a member of the AIRegion."
Volume46 = "The name of a volume that is a member of the AIRegion."
Volume47 = "The name of a volume that is a member of the AIRegion."
Volume48 = "The name of a volume that is a member of the AIRegion."
Volume49 = "The name of a volume that is a member of the AIRegion."
Volume50 = "The name of a volume that is a member of the AIRegion."
Volume51 = "The name of a volume that is a member of the AIRegion."
Volume52 = "The name of a volume that is a member of the AIRegion."
Volume53 = "The name of a volume that is a member of the AIRegion."
Volume54 = "The name of a volume that is a member of the AIRegion."
Volume55 = "The name of a volume that is a member of the AIRegion."
Volume56 = "The name of a volume that is a member of the AIRegion."
Volume57 = "The name of a volume that is a member of the AIRegion."
Volume58 = "The name of a volume that is a member of the AIRegion."
Volume59 = "The name of a volume that is a member of the AIRegion."
Volume60 = "The name of a volume that is a member of the AIRegion."
Volume61 = "The name of a volume that is a member of the AIRegion."
Volume62 = "The name of a volume that is a member of the AIRegion."
Volume63 = "The name of a volume that is a member of the AIRegion."
Volume64 = "The name of a volume that is a member of the AIRegion."
Volume65 = "The name of a volume that is a member of the AIRegion."
Volume66 = "The name of a volume that is a member of the AIRegion."
Volume67 = "The name of a volume that is a member of the AIRegion."
Volume68 = "The name of a volume that is a member of the AIRegion."
Volume69 = "The name of a volume that is a member of the AIRegion."
Volume70 = "The name of a volume that is a member of the AIRegion."
Volume71 = "The name of a volume that is a member of the AIRegion."
Volume72 = "The name of a volume that is a member of the AIRegion."
Volume73 = "The name of a volume that is a member of the AIRegion."
Volume74 = "The name of a volume that is a member of the AIRegion."
Volume75 = "The name of a volume that is a member of the AIRegion."
Volume76 = "The name of a volume that is a member of the AIRegion."
Volume77 = "The name of a volume that is a member of the AIRegion."
Volume78 = "The name of a volume that is a member of the AIRegion."
Volume79 = "The name of a volume that is a member of the AIRegion."
Volume80 = "The name of a volume that is a member of the AIRegion."
Volume81 = "The name of a volume that is a member of the AIRegion."
Volume82 = "The name of a volume that is a member of the AIRegion."
Volume83 = "The name of a volume that is a member of the AIRegion."
Volume84 = "The name of a volume that is a member of the AIRegion."
Volume85 = "The name of a volume that is a member of the AIRegion."
Volume86 = "The name of a volume that is a member of the AIRegion."
Volume87 = "The name of a volume that is a member of the AIRegion."
Volume88 = "The name of a volume that is a member of the AIRegion."
Volume89 = "The name of a volume that is a member of the AIRegion."
Volume90 = "The name of a volume that is a member of the AIRegion."
Volume91 = "The name of a volume that is a member of the AIRegion."
Volume92 = "The name of a volume that is a member of the AIRegion."
Volume93 = "The name of a volume that is a member of the AIRegion."
Volume94 = "The name of a volume that is a member of the AIRegion."
Volume95 = "The name of a volume that is a member of the AIRegion."
Volume96 = "The name of a volume that is a member of the AIRegion."
Volume97 = "The name of a volume that is a member of the AIRegion."
Volume98 = "The name of a volume that is a member of the AIRegion."
Volume99 = "The name of a volume that is a member of the AIRegion."
Volume10 = "The name of a volume that is a member of the AIRegion."
Volume101 = "The name of a volume that is a member of the AIRegion."
Volume102 = "The name of a volume that is a member of the AIRegion."
Volume103 = "The name of a volume that is a member of the AIRegion."
Volume104 = "The name of a volume that is a member of the AIRegion."
Volume105 = "The name of a volume that is a member of the AIRegion."
Volume106 = "The name of a volume that is a member of the AIRegion."
Volume107 = "The name of a volume that is a member of the AIRegion."
Volume108 = "The name of a volume that is a member of the AIRegion."
Volume109 = "The name of a volume that is a member of the AIRegion."
Volume110 = "The name of a volume that is a member of the AIRegion."
Volume111 = "The name of a volume that is a member of the AIRegion."
Volume112 = "The name of a volume that is a member of the AIRegion."
Volume113 = "The name of a volume that is a member of the AIRegion."
Volume114 = "The name of a volume that is a member of the AIRegion."
Volume115 = "The name of a volume that is a member of the AIRegion."
Volume116 = "The name of a volume that is a member of the AIRegion."
Volume117 = "The name of a volume that is a member of the AIRegion."
Volume118 = "The name of a volume that is a member of the AIRegion."
Volume119 = "The name of a volume that is a member of the AIRegion."
Volume120 = "The name of a volume that is a member of the AIRegion."
Volume121 = "The name of a volume that is a member of the AIRegion."
Volume122 = "The name of a volume that is a member of the AIRegion."
Volume123 = "The name of a volume that is a member of the AIRegion."
Volume124 = "The name of a volume that is a member of the AIRegion."
Volume125 = "The name of a volume that is a member of the AIRegion."
Volume126 = "The name of a volume that is a member of the AIRegion."
Volume127 = "The name of a volume that is a member of the AIRegion."
Volume128 = "The name of a volume that is a member of the AIRegion."
PostSearchMsg1  = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg2  = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg3  = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg4  = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg5  = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg6  = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg7  = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg8  = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg9  = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg10 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg11 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg12 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg13 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg14 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg15 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg16 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg17 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg18 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg19 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg20 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg21 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg22 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg23 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg24 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg25 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg26 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg27 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg28 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg29 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg30 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg31 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."
PostSearchMsg32 = "A command that is executed after a searching AI has no search nodes left to check in the AIRegion."

[AIVolume]

Lit = "Whether or not the volume starts lit (this will be used in the future with dynamic lights and hiding volumes.)"
ViewNode1 = "The name of an AINodeView that can see this AIVolume."
ViewNode2 = "The name of an AINodeView that can see this AIVolume."
ViewNode3 = "The name of an AINodeView that can see this AIVolume."
ViewNode4 = "The name of an AINodeView that can see this AIVolume."
ViewNode5 = "The name of an AINodeView that can see this AIVolume."
ViewNode6 = "The name of an AINodeView that can see this AIVolume."
ViewNode7 = "The name of an AINodeView that can see this AIVolume."
ViewNode8 = "The name of an AINodeView that can see this AIVolume."
ViewNode9 = "The name of an AINodeView that can see this AIVolume."
ViewNode10 = "The name of an AINodeView that can see this AIVolume."
ViewNode11 = "The name of an AINodeView that can see this AIVolume."
ViewNode12 = "The name of an AINodeView that can see this AIVolume."
ViewNode13 = "The name of an AINodeView that can see this AIVolume."
ViewNode14 = "The name of an AINodeView that can see this AIVolume."
ViewNode15 = "The name of an AINodeView that can see this AIVolume."
ViewNode16 = "The name of an AINodeView that can see this AIVolume."
Region = "Name of the AIRegion that this volume belongs to, for searching and responding to alarms."
PreferredPath = "Is this volume preferred by AI when planning a path?"
LightSwitchNode = "Name of lightswitch AINodeUseObject that corresponds to this volume."

[AIVolumeLadder]

[AIVolumeStairs]

[AIVolumeLedge]

[AIVolumeHiding]
On = "Indicates if the hiding volume should start in the enabled state."

[AIVolumeJunction]

Volume1Name				= "The name of a neighboring volume."
Volume1Action1			= "One of the potential actions to take when the AI loses the player in this volume, while moving to Volume1."
Volume1Action1Chance	= "The chance that Action1 will be taken. [The sum of all chances should be 1.0]"
Volume1Action2			= "One of the potential actions to take when the AI loses the player in this volume, while moving to Volume1."
Volume1Action2Chance	= "The chance that Action2 will be taken. [The sum of all chances should be 1.0]"
Volume1Action3			= "One of the potential actions to take when the AI loses the player in this volume, while moving to Volume1."
Volume1Action3Chance	= "The chance that Action3 will be taken. [The sum of all chances should be 1.0]"
Volume1Action4			= "One of the potential actions to take when the AI loses the player in this volume, while moving to Volume1."
Volume1Action4Chance	= "The chance that Action4 will be taken. [The sum of all chances should be 1.0]"
Volume2Name				= "The name of a neighboring volume."
Volume2Action1			= "One of the potential actions to take when the AI loses the player in this volume, while moving to Volume2."
Volume2Action1Chance	= "The chance that Action1 will be taken. [The sum of all chances should be 1.0]"
Volume2Action2			= "One of the potential actions to take when the AI loses the player in this volume, while moving to Volume2."
Volume2Action2Chance	= "The chance that Action2 will be taken. [The sum of all chances should be 1.0]"
Volume2Action3			= "One of the potential actions to take when the AI loses the player in this volume, while moving to Volume2."
Volume2Action3Chance	= "The chance that Action3 will be taken. [The sum of all chances should be 1.0]"
Volume2Action4			= "One of the potential actions to take when the AI loses the player in this volume, while moving to Volume2."
Volume2Action4Chance	= "The chance that Action4 will be taken. [The sum of all chances should be 1.0]"
Volume3Name				= "The name of a neighboring volume."
Volume3Action1			= "One of the potential actions to take when the AI loses the player in this volume, while moving to Volume3."
Volume3Action1Chance	= "The chance that Action1 will be taken. [The sum of all chances should be 1.0]"
Volume3Action2			= "One of the potential actions to take when the AI loses the player in this volume, while moving to Volume3."
Volume3Action2Chance	= "The chance that Action2 will be taken. [The sum of all chances should be 1.0]"
Volume3Action3			= "One of the potential actions to take when the AI loses the player in this volume, while moving to Volume3."
Volume3Action3Chance	= "The chance that Action3 will be taken. [The sum of all chances should be 1.0]"
Volume3Action4			= "One of the potential actions to take when the AI loses the player in this volume, while moving to Volume3."
Volume3Action4Chance	= "The chance that Action4 will be taken. [The sum of all chances should be 1.0]"
Volume4Name				= "The name of a neighboring volume."
Volume4Action1			= "One of the potential actions to take when the AI loses the player in this volume, while moving to Volume4."
Volume4Action1Chance	= "The chance that Action1 will be taken. [The sum of all chances should be 1.0]"
Volume4Action2			= "One of the potential actions to take when the AI loses the player in this volume, while moving to Volume4."
Volume4Action2Chance	= "The chance that Action2 will be taken. [The sum of all chances should be 1.0]"
Volume4Action3			= "One of the potential actions to take when the AI loses the player in this volume, while moving to Volume4."
Volume4Action3Chance	= "The chance that Action3 will be taken. [The sum of all chances should be 1.0]"
Volume4Action4			= "One of the potential actions to take when the AI loses the player in this volume, while moving to Volume4."
Volume4Action4Chance	= "The chance that Action4 will be taken. [The sum of all chances should be 1.0]"

[AICmd]
Next1 = "Another AICmd that the AI will execute after this command finishes. (Only works with certain AICmds)."
Next2 = "Another AICmd that the AI will execute after this command finishes. (Only works with certain AICmds)."
Next3 = "Another AICmd that the AI will execute after this command finishes. (Only works with certain AICmds)."
Next4 = "Another AICmd that the AI will execute after this command finishes. (Only works with certain AICmds)."
Next5 = "Another AICmd that the AI will execute after this command finishes. (Only works with certain AICmds)."
Next6 = "Another AICmd that the AI will execute after this command finishes. (Only works with certain AICmds)."
Next7 = "Another AICmd that the AI will execute after this command finishes. (Only works with certain AICmds)."
Next8 = "Another AICmd that the AI will execute after this command finishes. (Only works with certain AICmds)."
Interrupt = "Determines if the AI will update its senses while executing the command. (Only works with certain AICmds.)"

[AICmdIdle]

[AICmdAware]

[AICmdLookAt]
Position = "The position, in world space, that the AI should look at."

[AICmdTail]
Node1 = "Node used in the tail state."
Node2 = "Node used in the tail state."
Node3 = "Node used in the tail state."
Node4 = "Node used in the tail state."
Node5 = "Node used in the tail state."
Node6 = "Node used in the tail state."
Node7 = "Node used in the tail state."
Node8 = "Node used in the tail state."
Node9 = "Node used in the tail state."
Node10 = "Node used in the tail state."
Node11 = "Node used in the tail state."
Node12 = "Node used in the tail state."

[AICmdFollowFootprint]
Search = "Should the AI go into the search state when done following the footprints?"

[AICmdInvestigate]
Enemy = "The name of the enemy the AI should target when investigating."
Sense = "The type of sensory stimulus the AI should investigate."
Position = "The position from which the sense stimulus originated."
Search = "Should the AI go into the search state when done investigating the sensory stimulus?"

[AICmdCheckBody]
Body = "The name of the body that should be checked."
Search = "Should the AI go into the search state when done checking the body?"

[AICmdSearch]
Engage = "Should the AI run to the region containing its target before searching?"
Face = "Should the AI face along the forward vector of the search node when it arrives there?"
Pause = "Should the AI pause before beginning its search?"

[AICmdCharge]
AttackDist = "The distance at which the AI will begin firing on its target."
YellDist = "The distance at which the AI will yell (once) at its target."
StopDist = "The distance at which the AI will stop charging and go into the attack state."

[AICmdChase]

[AICmdPanic]
Node = "The node the AI should panic at"
CanActivate = "Whether or not the AI may be activated by the player while it is panicking."

[AICmdDistress]
CanActivate = "Whether or not the AI may be activated by the player while it is distressed."

[AICmdDrowsy]

[AICmdUnconscious]
Aware = "Should the AI go into the aware state after waking up?"
Time = "Indicates how long the AI should stay unconscious."

[AICmdStunned]

[AICmdAttack]

Chase = "Can the AI go into the chase state if it loses sight of its target?"
ChaseDelay = "How long the AI must wait before it can go into the chase state when it loses sight of the player."
Posture = "The posture the AI should take while firing (crouching, standing, etc)"

[AICmdDraw]

[AICmdAttackFromCover]
Node = "The node to use cover at. Should be an AINodeCover."

[AICmdAttackFromVantage]

[AICmdAttackFromView]
Node = "The node to use for a view. Should be an AINodeView."

[AICmdAttackOnSight]
ChaseDelay = "How long the AI must wait before it can go into the chase state when it loses sight of the player."

[AICmdAssassinate]
Node = "The node to assassinate from."
Move = "The style of movement the AI should use to get to the node - move, walk, etc"
IgnoreVisibility = "Should the AI fire regardless of whether or not it can see its target?"

[AICmdCover]

[AICmdPatrol]
Node = "The first node on the patrol path. Should be an AINodePatrol."

[AICmdGoto]
Node1 = "The 1st node to go to."
Node2 = "The 2nd node to go to."
Node3 = "The 3rd node to go to."
Node4 = "The 4th node to go to."
Node5 = "The 5th node to go to."
Node6 = "The 6th node to go to."
Node7 = "The 7th node to go to."
Node8 = "The 8th node to go to."
Node9 = "The 9th node to go to."
Node10 = "The 10th node to go to."
Node11 = "The 11th node to go to."
Node12 = "The 12th node to go to."
Move = "The style of movement the AI should use to get to the node - move, walk, etc"
Face = "Should the AI face along the forward vector of each goto node when it arrives there."
Loop = "Should the AI loop back through all the nodes indefinitely?"

[AICmdFlee]
Danger = "The name of the object that the AI should flee from."

[AICmdFollow]
Range = "The distance at which the AI should stay from its target"
RangeTime = "After the target moves beyond the AI's follow range, the AI will wait this long before starting to close follow the target."
Move = "The style of movement the AI should use to get to the node - move, walk, etc"

[AICmdGetBackup]
Node = "The node to use for getting backup. Should be an AINodeBackup."
Move = "The style of movement the AI should use to get to the node - move, walk, etc"

[AICmdUseObject]
Node = "The node to use for using an object. Should be an AINodeUseObject."
Move = "The style of movement the AI should use to get to the node - move, walk, etc"

[AICmdPickupObject]
Node = "The node to use for picking up an object. Should be an AINodePickupObject."
Move = "The style of movement the AI should use to get to the node - move, walk, etc"

[AICmdTalk]
Face = "The name of the object that the AI should face while talking."
FaceTime = "How long the AI should continue to face the object after it has stopped talking."
Mood = "Controls the animation the AI plays while talking."

[AICmdAnimate]
Animation = "The name of the animation to play."
Loop = "Whether or not to loop the animation."

[AICmdAttackProp]
Prop = "The name of the prop to attack."

[AICmdTarget]
Target = "The name of the object to target."

[AICmdFace]
Face = "What to face - target, object, direction, position, etc"
Object = "The name of the object to face, if facing an object."
Position = "The position to face, if facing a position."
Direction = "The direction to face, if facing a direction."

[WorldModel]
DebrisType = "Identifies the type of debris that will be spawned by the destruction of the object."
SurfaceOverride = "This field overrides the surface flags assigned to the textures on the brush or brushes that make up the WorldModel. This is particularly useful in correcting any unwanted behavior resulting from a brush having multiple textures with differing surface flags applied."
Solid = "Is this Object solid or not."
Rayhit = "Will this Object be hit by ray casts."
Gravity = "Is this Object effected by gravity.  If this flag is true the Object will fall from mid air."
Chromakey = "Some textures create transparent and opaque areas defined by an alpha channel. Setting this flag to true tells the object to make use of this alpha mask."
BlockLight = "Setting this flag to true will cause the object to block light and cast a shadow."
BoxPhysics = "In the engine, WorldModels have two possible physics models. In the first, the player can walk on and touch every curve and corner of their surface. In the second, the player can only interact with a bounding box that surrounds all the brushes in the WorldModel, just like the box you would get if you selected them in DEdit. For geometry with a simple rectangular shape, this is preferred because it's cheaper to calculate. However, for a lot of objects, it's limiting. If you need a player to be able to shoot through the bars in a prison door, you will need BoxPhysics set to FALSE."
FogDisable = "Setting this flag to true will cause the object to not be affected by fog"
IsKeyframed = "Is the WorldModel moved by a keyframer? If it is you will want to set this flag to true. If you do not, impact effects will not move with the object. They will instead, hover in the air as the WorldModel object moves away from them."
Attachments = "Using this field you can list Objects, Models, and WorldModels that will move with the WorldModel object while maintaining their relative position and rotation. This is commonly used to add Props like door knobs to doors. List all Objects you want attached seperated by a semicolon.  Ex. Prop1; RotatingWorldModel2; Prop2; WorldModel1"
RemoveAttachments = "If this property is set to true, attachments will be removed (i.e., disappear) when the WorldModel is removed (destroyed).  If this property is set to false, the attachments will receive 'destroy' messages and will be destroyed (if they are set up to respond to the destroy message)."
AttachDir = "This is the direction (and magnitude) away from the center of the WorldModel a ray is cast that looks for an object to attach to the WorldModel (when the WorldModel receives an Attach message)."
BlendMode = "Use this dropdown list to set the WorldModel to be Additive or Translucent."
StartHidden = "If this flag is true the WorldModel will be created as if it were sent a HIDDEN 1 message."
Alpha = "Specifies the alpha of the WorldModel."
ActivateAlarmLevel = "How alarming it is to the AI when this object is activated. Corresponds to thresholds in AIBrains in aibutes.txt."
DestroyAlarmLevel = "How alarming it is to the AI when this object is detroyed. Corresponds to thresholds in AIBrains in aibutes.txt."
StimulusRadius = "How far away this object is noticeable to AI when disturbed."
Disturbances = "Properties related to AI disturbances."

[ActiveWorldModel]
Options = "This is a subset of properties that define some behavior of the Object"
StartOn = "When set to TRUE the object will be turnning on as soon as the game loads."
TriggerOff = "If this is set to FALSE the player can not directly turn the object off by pressing use.  The object can however be turned off by a message from another object like a switch.  If set to TRUE the player can directly turn off or close the object by pressing use."
ForceMove = "If set to TRUE, the object will not be stopped by the player or AI.  It will continue on its path like there is nothing in the way."
ForceMoveOn = "If set to TRUE, the object will not be stopped by the player or AI when going on.  It will continue on its path like there is nothing in the way."
ForceMoveOff = "If set to TRUE, the object will not be stopped by the player or AI when going off.  It will continue on its path like there is nothing in the way."
Locked = "When set to TRUE the object starts in a ""Locked"" state.  It can't be activated or triggered by a message unless it is unlocked.  To unlock an object send it an UNLOCK message.  To lock it again send a LOCK message." 
Waveform = "A list of predefined wave types for movement.  Linear is a constant rate, objects will move at the same rate throught its whole path or rotation. SlowOn means the object starts moving slowly then picks up pace and will then stay constant.  SlowOff will move constantly at first but will slow down at the end of the movement or rotation.  Sine starts and ends slowly but looks very smooth and natural."        
PlayerActivate = "If TRUE the player can directly interact with this object by pressing use."
AIActivate = "If TRUE this lets the AI know they can interact with this object.  When FALSE the AI will treat the object like it doesn't exist."
RemainOn = "If this is FALSE the Object will start turnning itself off or close as soon as it turns on or opens.  If TRUE the object will stay on or open untill told to turn off, either by the player or a message."
RotateAway = "If set to TRUE RotatingWorldModels will rotate away from the player or AI that activated it."
ActivateType = "This is a dropdown list of predefined ActivationTypes.  When an ActivationType is specified and the player places their cross hair over the object the text specified in the ActiavationType will be displayed."
Sounds = "This is a subset of properties that define sound behavior and let you specify different sounds to play during different states."
PowerOnSound = "The path of any .wav file can be entered here.  This sound will begin playing as soon as the object starts to turn on."
OnSound = "The path of any .wav file can be entered here.  This sound will begin playing as soon as the object is fully turned on."
PowerOffSound = "The path of any .wav file can be entered here.  This sound will begin playing as soon as the object starts to turn off."
OffSound = "The path of any .wav file can be entered here.  This sound will begin playing as soon as the object is fully turned off."
LockedSound = "The path of any .wav file can be entered here.  If this object is locked and the player or another object tries to activate it, this sound will begin to play."
SoundPos = "The position that the sounds will be played from, relative to the objects position.  If this is (0.0 0.0 0.0) the sounds will play at the center of the object, (0.0 25.0 0.0) will place the sounds 25 units above the objects center."
SoundRadius = "This is the extent of the sounds, they will not be heard beyond this distance from the SoundPos."
LoopSounds = "When set to TRUE, the sounds will comtinue to loop untill they change state.  When FALSE the sounds will play their full length once and will then be destroyed."
Commands = "This is a subset that lets you write commands for specific states that the object will cary out when in that state."
PowerOnCommand = "A command that this object will execute when starting to turn on."
OnCommand = "A command that this object will execute when it is fully on."
PowerOffCommand = "A command that this object will execute when starting to turn off."
OffCommand = "A command that this object will execue when it is fully off."
LockedCommand = "If this object is locked and the player or another object tries to activate it, this command will be executed."
MoveDir = "This is the direction of movement this object will go when turned on.  This is relative to the objects local coordinates so a MoveDir of (0.0 1.0 0.0) will always move in the objects positive Y direction."
MoveDist = "This is the distance the object will move in the direction specified in MoveDir."
RotationPoint = "The name of a ""Point"" object which this WorldModel will rotate around.  If no valid object name is given the WorldModel will rotate around the position of the bound object." 
RotationAngles = "These represent how far the WorldModel will rotate around the RotationPoint in the specified axi when turned on.  (0.0 90.0 0.0) will rotate the WorldModel about the RotationPoint 90 degrees around the WorldModels local Y axis."
PowerOnTime = "Sets the time in seconds for how long it takes the WorldModel to go from the Off state to the on state."
PowerOffTime = "If other than 0.0, sets the time in seconds for how long it takes the WorldModel to go from the On state to the off state.  If this is 0.0 then the PowerOnTime value is used." 
MoveDelay = "Amount of delay in seconds between the time the WorldModel is triggered and when it begins its movement."
OnWaitTime = "Amount of time in seconds that the WorldModel will remain on before turnning off automatically, and the amount of time before the WorldModel can be triggered on again." 
OffWaitTime = "Amount of time in secomds before the WorldModel can be turned on after being turned off."

[Door]
StartOpen = "When set to true the Door will be opening as soon as the game loads."
TriggerClose = "If this is set to FALSE the player can not directly close the Door by pressing use.  The Door can however be closed by a message from another object like a switch.  If set to TRUE the player can directly close the Door by pressing use."
RemainOpen = "If set to FALSE the Door will try to start closing as soon as it becomes fully open.  If TRUE the Door will stay open untill told to close, either by the player or a message from another object."
OpenAway = "If set to TRUE the RotatingDoor will open away from the player or AI that activated it."
OpeningSound = "The path of any .wav file can be entered here.  This sound will begin playing as soon as the Door starts opening."
OpenSound = "The path of any .wav file can be entered here.  This sound will begin playing as soon as the Door is fully opened."
ClosingSound = "The path of any .wav file can be entered here.  This sound will begin playing as soon as the Door starts closing."
ClosedSound = "The path of any .wav file can be entered here.  This sound will begin playing as soon as the object is fully closed."
OpeningCommand = "A command that this Door will execute when starting to open."
OpenCommand = "A command that this Door will execute when it is fully open."
ClosingCommand = "A command that this Door will execute when starting to close."
ClosedCommand = "A command that this Door will execue when it is fully closed."
LockedCommand = "If this object is locked and the player or another object tries to activate it, this command will be executed."
OpeningTime = "Sets the time in seconds for how long it takes the WorldModel to go from the Off state to the on state."
ClosingTime = "If other than 0.0, sets the time in seconds for how long it takes the WorldModel to go from the On state to the off state.  If this is 0.0 then the OpeningTime value is used." 
OpenWaitTime = "Amount of time in seconds that the Door will remain open before automatically closing, and the amount of time before the Door can be triggered again." 
CloseWaitTime = "Amount of time in secomds before the Door can be opened after being closed."
PortalName = "The name of a portal brush that this Door will open and close with it."
DoorLink = "Use this to link two Doors together that you would like to open at the same time (i.e., Door1's DoorLink would be Door2, and Door2's DoorLink would be Door1).  NOTE--Only the opening of linked doors is supported. Each door may be closed individually."

[CommandObject]
EventCommands = "This brings up the Command Manager dialog box for easy creation and editing of event commands."
FinishedCommand = "A command that will be executed when the CommandObject is done sending event commands or is turned off through a message."
NumberOfActivations = "This specifies how many times the CommandObject may be activated.  Once the CommandObject has been activated NumberOfActivations times it gets removed and can no longer be activated.  Specify -1 for infinite activations."
Locked = "If true the CommandObject will be locked and unactivatable until unlocked."

[Dialogue]
StartCommand = "A command that will be executed when the Dialogue object is first turned on."
FinishedCommand = "A command that will be executed when the Dialogue natrually finishes playing all the dialogues."
CleanUpCommand = "A command that will always be executed whenever the Dialogue stops, either naturally or by messaged to stop."
Dialogue = "This is a subset that allows you to create a conversation between characters."
Delay1 = "The amount of time, in seconds, to wait before starting this portion of the conversation."
Dialogue1 = "This specifies the actual sound that gets played and the object that plays it.  You can enter in the path and filename of a sound or an ID for a specific sound followed by the character who plays it.  EX: (Voice\SOUND_NAME.wav) (Player)"
StartDialogueCommand1 = "A command that will be executed when this portion of the conversation begins to play."
RemoveWhenComplete = "Remove the dialogue object after dialogue is complete."

[LightGroup]
StartOn = "The initial state of the lightgroup."
StartColor = "The initial color of the lightgroup."

[GadgetTarget]
GadgetTargetName = "A list of GadgetTargets defined in gadgettargets.txt.  The 'Type' of GadgetTarget defines which gadgets can interact with it."
CodeID = "A multi purpose property.  For GadgetTargets of Type Keypad, this is the coded number that will be deciphered.  For Codedtext GadgetTargets this is the ID of a string in Cres.dll the will be deciphered."
MinTime = "If other than 0 this will override the MinTime property in gadgettargets.txt.  This is the Minimum ammount of time it takes to disable this gadget target."
MaxTime = "If other the 0 this will override the MatTime property in gadgettargets.txt.  This is the maxium ammount of time it takes to disable this gadget target."
Command = "A commmand that will be executed when the Gadget Target has been disabled."
PowerOffCommand = "A command that will be executed when the GadgetTarget has been activated and the power is off."
StartOn = "If true the GadgetTarget will be considered on."
Team = "A dropdown list of teams that specifies which team owns the GadgetTarget.  Only players on the owning team are allowed to disable the gadget target.  If NoTeam is specified then all players are allowed to disable the GadgetTarget."

[Bombable]
DefuseTime = "The ammount of time it takes to defuse this time bomb."
PlantedCommand = "A command that will be executed when a time bomb is planted on the bombable area."
DetonatedCommand = " A command that will be executed when the time bomb's life time is up."
DefusedCommand = "A command that will be executed when the time bomb is defused by a player."
DetonateTime = "This specifies how long, in seconds, it takes for the planted explosives to detonate.  Enter -1 for no detonation time so other objects can send control when it detonates." 
StartPlanted = "If true the Bombable will begin with explosives already planted."
CanDefuse = "If true players are allowed to defuse the planted explosives."
DefuseOnce = "If false, explosives can continuely be planted and defused untill one actually detonates."

[PlayerLure]
PlayerLureCameraFreedom = "Specifies the amount of restriction to place on the camera rotation."
LimitedYawLeftRight = "Specifies camera rotation to left and right of center that is allowed.  Separate left and right value with a space.  Setting left < -180 and right > 180 means unlimited yaw."
LimitedPitchDownUp = "Specifies camera rotation down and up from center that is allowed.  Separate down and up value with a space.  Unlimited pitch is not allowed."
AllowWeapon = "Allow/disallow the weapon during lure.  Default:  False"
RetainOffsets = "Player retains position and rotation offset from PlayerLure.  Default:  False."
Bicycle = "Specifies whether to do bicycle camera work for lure."
DeathFX = "DeathFX to play if player dies while following lure."

[VolumeEffect]
Dims = "The Dims define the volume an effect takes place in. It is an area defined in DEdit units as a box around the center of the effect object."

[ScatterVolume]
Density = "The number of particles placed per 256 square units of surface area.  The density can be reduced by placement texture blending and clumpiness."
Clumpiness = "A number between 0 and 1 that specifies how much particles will 'clump' together.  0 distributes particles evenly over the surface, while 1 will result in very clumpy placement.  This works about the same as a 'Noise' texture in Max or Maya."
ClumpSize = "The approximate dimensions of a clump before it has been modified with the clump cutoff value.  Also the approximate distance between clumps."
ClumpCutoff = "A number between 0 and 1 that specifies how sharp the edges of clumps should be.  0 will result in a smooth falloff in density towards the edges of the clump, while higher numbers will result in sharper edges and fewer stragglers.  Numbers above about 0.7 will result in VERY sparse placement."
ClumpOffset = "By default, different scatter volumes will have clumps in the same locations in world space.  This can be useful for having multiple textures within the same clump.  If you really want the clumps to be independent of each other, change the clump offset in one of the volumes.  A good value might be 50 50 50 for example."
Width = "The base width of the quad that is rendered for each particle.  Note that this is independent of texture aspect ratio, so if you texture is 256x64, you would probably enter a width that is 4 times larger than the height."
Height = "The base height of the quad that is rendered for each particle.  Note that this is independent of texture aspect ratio, so if you texture is 256x64, you would probably enter a width that is 4 times larger than the height."
Tilt = "The range of tilt that particles may be placed at.  This value is in degrees."
ScaleRange = "The +/- range of scales that different particles will have.  For example, value of 0.2 will result in particles that are between 80%% and 120%% of the base width and height."
WaveRate = "The speed of the wave motion of the particles.  This is in degrees per second, so 360 will result in a complete wave cycle every second, while 90 will result in a complete wave cycle every 4 seconds."
WaveDist = "The distance in DEdit units to move the top of the particles.  For example, value of 10 will result in a total movement range of 10 units in either direction."
WaveSize = "The approximate dimensions of an area of common movement.  Over this area, particles will wave approximately in unison, smoothly blending to other nearby motions.  This works about the same as a 'Noise' texture in Max or Maya."
MaxDrawDist = "The maximum distance at which particles in a subvolume of this volume will be visible."
TextureName = "The texture that will be placed on the rendered quad.  Particles are placed on the surface based on the bottom center of the quad, so it is usually best for textures to have an anchor point at the bottom center as well."
PlantDepth = "A value that specifies how far the particle should be embedded in the surface.  If this is negative, then the particles will float above the surface."
PlacementTexture = "This is an optional texture that is only used for placing textures.  If this is not empty, then particles will only be placed on polygons that have this texture applied to them.  If multi-texturing is in use, then the amount of this texture will be used to change the density based on vertex alpha."
PlacementCutoff = "If multi-texturing is in use on a polygon, then points on the surface with a vertex alpha value less than this value will not have any particles placed on them."
UseSaturate = "If this is true and the saturate console variable is set, then the colors will be more saturated."
WaveDirSize = "The size of areas of similar wind direction."
AmbientLight = "The base color of the particles before lighting is added."
OnlyUseAmbient = "No lights contribute to the color of the particles, only the ambient value is used."

[SnowVolume]
Density = "The number of particles placed per 256 cubic units of volume.  Snow volumes with different dimensions (vertical and XZ) but with the same density can be seemlessly placed next to each other since the density is relative to the volume and doesn't represent a specific number of particles."
ParticleRadius = "The approximate radius of a particle in DEdit units."
FallRate = "The speed at which snow will fall in DEdit units per second.  A value of 0 will result in particles that don't fall, but may still spin.  Negative values will not generate desirable results."
TumbleRate = "The number of degrees of rotation per second around a central point."
TumbleRadius = "The distance from the base particle position to rotate at.  0 will result in particles that fall straight down, 10 will result in particles that flutter up to 10 units in either direction as they fall."
MaxDrawDist = "The maximum distance at which particles are drawn.  Starting at about 80%% of this distance, particles will begin to fade out."
AmbientColor = "The base vertex color for the particles before lighting (if any) is applied."
UseLighting = "If enabled, particles will be lit at runtime.  This is very expensive, and will reduce the number of particles that can be drawn per frame."
TextureName = "The texture to render the particles with.  All of the mip levels need to have a black border at the top and right edges of the texture in order to render correctly.  The texture needs to use non-premultiplied alpha (for example, entirely white color channel, with the actual shape in the alpha channel.)"

[DecisionObject]
Radius = "Activation radius."
Choice1StringID = "String ID to display for choice."
Choice1Cmd = "Command to run for choice."
AbortCmd = "Command to run if dialogue aborted."
RemoveAfterChoice = "Remove the decision object after choice is made."

[GameBase]
Template = "Indicates that this object will not exist at runtime, and may be used as an object template for Spawner objects"
GameType = "This will bring up a dialog where you can set which game types this object will be allowed in."
SinglePlayer = "Allow object for Singleplayer games."
Cooperative = "Allow object for Cooperative games."
Deathmatch = "Allow object for Deathmatch games."
TeamDeathmatch = "Allow object for Team Deathmatch games."
DoomsDay = "Allow object for DoomsDay games."

[GameBaseLite]
GameType = "This will bring up a dialog where you can set which game types this object will be allowed in."
SinglePlayer = "Allow object for Singleplayer games."
Cooperative = "Allow object for Cooperative games."
Deathmatch = "Allow object for Deathmatch games."
TeamDeathmatch = "Allow object for Team Deathmatch games."
DoomsDay = "Allow object for DoomsDay games."

[DoomsDayDevice]
Team = "This is a dropdown that allows you to set which team owns the device.  Only plyaers of the owning team are allowed to place a DoomsDayPiece on a DoomsDayDevice and only playersnot on the owning team are allowed to steal a DoomsDayPiece from a DoomsDayDevice."
DropZoneRadius = "This specifies how close a player needs to be to the DoomsDayDevice in order to place a DoomsDayPiece when one is dropped."

[RadarObject]
Type = "Type defined in RadarTypes.txt"
StartOn = "Show the item upon creation."
Target = "Target object that represents the radarobject."
Team = "This is a dropdown that allows you to set which team can see the radarobject."

[StartupCommand]
Command = "Command to run when the level starts."
RoundCondition = "Startup command only fires when condition met of all, odd or even rounds."
SafeExecute = "Execute command safely.  Set to false if target of command needs to be modified before first update."